
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>store: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tabeth/concretedb/store/foundationdb_backup.go (82.7%)</option>
				
				<option value="file1">github.com/tabeth/concretedb/store/foundationdb_pitr.go (83.3%)</option>
				
				<option value="file2">github.com/tabeth/concretedb/store/foundationdb_store.go (91.0%)</option>
				
				<option value="file3">github.com/tabeth/concretedb/store/foundationdb_store_indexes.go (90.0%)</option>
				
				<option value="file4">github.com/tabeth/concretedb/store/foundationdb_store_ttl.go (88.6%)</option>
				
				<option value="file5">github.com/tabeth/concretedb/store/test_utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package store

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/apple/foundationdb/bindings/go/src/fdb"
        "github.com/apple/foundationdb/bindings/go/src/fdb/tuple"
        "github.com/google/uuid"
        "github.com/tabeth/concretedb/models"
        "github.com/tabeth/concretedb/store/internal/fdbadapter"
)

// Helpers
func serialize(v interface{}) ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(v)
}</span>

func deserialize(data []byte, v interface{}) error <span class="cov8" title="1">{
        return json.Unmarshal(data, v)
}</span>

// CreateBackup creates a backup of the specified table.
func (s *FoundationDBStore) CreateBackup(ctx context.Context, request *models.CreateBackupRequest) (*models.BackupDetails, error) <span class="cov8" title="1">{
        // 1. Basic Validation
        table, err := s.GetTable(ctx, request.TableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                return nil, models.New("ResourceNotFoundException", "Table not found")
        }</span>

        <span class="cov8" title="1">backupId := uuid.New().String()
        backupArn := fmt.Sprintf("arn:aws:dynamodb:us-east-1:123456789012:table/%s/backup/%s", request.TableName, backupId)
        now := float64(time.Now().Unix())

        details := &amp;models.BackupDetails{
                BackupArn:              backupArn,
                BackupName:             request.BackupName,
                BackupStatus:           "CREATING",
                BackupType:             "USER",
                BackupCreationDateTime: now,
                BackupSizeBytes:        0,
        }

        // 2. Store Metadata (Sync)
        _, err = s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                backupDir, err := s.getBackupMetadataDir(tr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">data, err := serialize(details)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">tr.Set(backupDir.Pack(tuple.Tuple{backupArn}), data)
                return nil, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 3. Async Backup Process
        <span class="cov8" title="1">go s.performBackupAsyncCorrect(request.TableName, backupArn, table)

        return details, nil</span>
}

// Fixed Async Backup
func (s *FoundationDBStore) performBackupAsyncCorrect(tableName string, backupArn string, sourceTable *models.Table) <span class="cov8" title="1">{
        res, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                tableDir, err := s.dir.Open(tr, []string{"tables", tableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">backupDataDir, err := s.getBackupDataDir(tr, backupArn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">metaDataBytes, err := serialize(sourceTable)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tr.Set(backupDataDir.Pack(tuple.Tuple{"_metadata"}), metaDataBytes)

                totalBytes := int64(len(metaDataBytes))

                // Fix Range Calculation: FDBRangeKeys returns (begin, end) for the directory subspace
                // But tableDir is likely /root/content/tables/NAME
                // We want to scan everything under that.
                beginKey, endKey := tableDir.FDBRangeKeys()
                r := fdb.KeyRange{Begin: beginKey, End: endKey}

                iter := tr.GetRange(r, fdb.RangeOptions{
                        Mode: fdb.StreamingModeWantAll,
                }).Iterator()

                count := 0
                for iter.Advance() </span><span class="cov8" title="1">{
                        kv, err := iter.Get()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">srcPrefix := tableDir.Bytes()
                        if len(kv.Key) &lt; len(srcPrefix) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">suffix := kv.Key[len(srcPrefix):]

                        destKey := append(backupDataDir.Bytes(), suffix...)
                        tr.Set(fdb.Key(destKey), kv.Value)

                        totalBytes += int64(len(kv.Value) + len(destKey))
                        count++</span>
                }
                <span class="cov8" title="1">fmt.Printf("Backup Total Bytes: %d, Count: %d\n", totalBytes, count)
                return totalBytes, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                s.updateBackupStatus(backupArn, "DELETED")
                return
        }</span>

        <span class="cov8" title="1">totalBytes := res.(int64)
        s.updateBackupCompletion(backupArn, "AVAILABLE", totalBytes)</span>
}

func (s *FoundationDBStore) updateBackupStatus(backupArn string, status string) <span class="cov8" title="1">{
        _, _ = s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                backupDir, err := s.getBackupMetadataDir(tr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">key := backupDir.Pack(tuple.Tuple{backupArn})
                valBytes, err := tr.Get(key).Get()
                if err != nil || valBytes == nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">var details models.BackupDetails
                if err := deserialize(valBytes, &amp;details); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">details.BackupStatus = status
                newData, _ := serialize(details)
                tr.Set(key, newData)
                return nil, nil</span>
        })
}

func (s *FoundationDBStore) updateBackupCompletion(backupArn string, status string, sizeBytes int64) <span class="cov8" title="1">{
        _, _ = s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                backupDir, err := s.getBackupMetadataDir(tr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">key := backupDir.Pack(tuple.Tuple{backupArn})
                valBytes, err := tr.Get(key).Get()
                if err != nil || valBytes == nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">var details models.BackupDetails
                if err := deserialize(valBytes, &amp;details); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">details.BackupStatus = status
                details.BackupSizeBytes = sizeBytes
                newData, _ := serialize(details)
                tr.Set(key, newData)
                return nil, nil</span>
        })
}

// RestoreTableFromBackup creates a new table from a backup.
func (s *FoundationDBStore) RestoreTableFromBackup(ctx context.Context, request *models.RestoreTableFromBackupRequest) (*models.TableDescription, error) <span class="cov8" title="1">{
        exists, err := s.GetTable(ctx, request.TargetTableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if exists != nil </span><span class="cov8" title="1">{
                return nil, models.New("ResourceInUseException", "Table already exists")
        }</span>

        <span class="cov8" title="1">var backupDetails models.BackupDetails
        var msg string

        _, err = s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                backupMetaDir, err := s.getBackupMetadataDir(tr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">key := backupMetaDir.Pack(tuple.Tuple{request.BackupArn})
                valBytes, err := tr.Get(key).Get()
                if err != nil || valBytes == nil </span><span class="cov8" title="1">{
                        msg = "Backup not found"
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, deserialize(valBytes, &amp;backupDetails)</span>
        })

        <span class="cov8" title="1">if msg != "" </span><span class="cov8" title="1">{
                return nil, models.New("ResourceNotFoundException", msg)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if backupDetails.BackupStatus != "AVAILABLE" </span><span class="cov0" title="0">{
                return nil, models.New("BackupInUseException", "Backup is not available")
        }</span>

        <span class="cov8" title="1">var sourceTable models.Table
        _, err = s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                backupDataDir, err := s.getBackupDataDir(tr, request.BackupArn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">valBytes, err := tr.Get(backupDataDir.Pack(tuple.Tuple{"_metadata"})).Get()
                if err != nil || valBytes == nil </span><span class="cov0" title="0">{
                        msg = "Corrupted backup: missing metadata"
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, deserialize(valBytes, &amp;sourceTable)</span>
        })
        <span class="cov8" title="1">if msg != "" </span><span class="cov0" title="0">{
                return nil, models.New("InternalServerError", msg)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">newTable := sourceTable
        newTable.TableName = request.TargetTableName
        newTable.CreationDateTime = time.Now()
        newTable.Status = models.StatusCreating

        err = s.CreateTable(ctx, &amp;newTable)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">go s.performRestoreAsync(request.TargetTableName, request.BackupArn)

        desc := &amp;models.TableDescription{
                TableName:             newTable.TableName,
                TableStatus:           "CREATING",
                AttributeDefinitions:  newTable.AttributeDefinitions,
                KeySchema:             newTable.KeySchema,
                ProvisionedThroughput: newTable.ProvisionedThroughput,
                TableSizeBytes:        0,
                ItemCount:             0,
                CreationDateTime:      float64(newTable.CreationDateTime.Unix()),
        }
        return desc, nil</span>
}

func (s *FoundationDBStore) performRestoreAsync(tableName string, backupArn string) <span class="cov8" title="1">{
        _, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                backupDataDir, err := s.getBackupDataDir(tr, backupArn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">targetDir, err := s.dir.Open(tr, []string{"tables", tableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">beginKey, endKey := backupDataDir.FDBRangeKeys()
                r := fdb.KeyRange{Begin: beginKey, End: endKey}
                iter := tr.GetRange(r, fdb.RangeOptions{Mode: fdb.StreamingModeWantAll}).Iterator()

                count := 0
                for iter.Advance() </span><span class="cov8" title="1">{
                        kv, err := iter.Get()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">backupPrefix := backupDataDir.Bytes()
                        if len(kv.Key) &lt; len(backupPrefix) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">suffix := kv.Key[len(backupPrefix):]

                        t, err := tuple.Unpack(suffix)
                        if err == nil &amp;&amp; len(t) &gt; 0 </span><span class="cov8" title="1">{
                                if str, ok := t[0].(string); ok </span><span class="cov8" title="1">{
                                        if str == "_metadata" || str == "metadata" </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">destKey := append(targetDir.Bytes(), suffix...)
                        tr.Set(fdb.Key(destKey), kv.Value)
                        count++</span>
                }
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Restore failed: %v\n", err)
                return
        }</span>

        // Update to Active
        <span class="cov8" title="1">s.setTableStatus(tableName, models.StatusActive)</span>
}

func (s *FoundationDBStore) setTableStatus(tableName string, status models.TableStatus) <span class="cov8" title="1">{
        _, _ = s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                dir, err := s.dir.Open(tr, []string{"tables", tableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">metaKey := dir.Pack(tuple.Tuple{"metadata"})
                valBytes, err := tr.Get(metaKey).Get()
                if err != nil || valBytes == nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">var table models.Table
                deserialize(valBytes, &amp;table)
                table.Status = status

                d, _ := serialize(table)
                tr.Set(metaKey, d)
                return nil, nil</span>
        })
}

// Helpers
func (s *FoundationDBStore) getBackupMetadataDir(tr fdbadapter.FDBTransaction) (fdbadapter.FDBDirectorySubspace, error) <span class="cov8" title="1">{
        return s.dir.CreateOrOpen(tr, []string{"backups", "metadata"}, nil)
}</span>

func (s *FoundationDBStore) getBackupDataDir(tr fdbadapter.FDBTransaction, backupArn string) (fdbadapter.FDBDirectorySubspace, error) <span class="cov8" title="1">{
        return s.dir.CreateOrOpen(tr, []string{"backups", "data", backupArn}, nil)
}</span>

func (s *FoundationDBStore) ListBackups(ctx context.Context, request *models.ListBackupsRequest) ([]models.BackupSummary, string, error) <span class="cov8" title="1">{
        summaries := []models.BackupSummary{}
        var lastKey string

        _, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                backupMetaDir, err := s.getBackupMetadataDir(tr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">beginKey, endKey := backupMetaDir.FDBRangeKeys()
                r := fdb.KeyRange{Begin: beginKey, End: endKey}

                if request.ExclusiveStartBackupArn != "" </span><span class="cov8" title="1">{
                        startKey := backupMetaDir.Pack(tuple.Tuple{request.ExclusiveStartBackupArn})
                        r.Begin = fdb.Key(append(startKey, 0x00))
                }</span>

                // Iterate
                <span class="cov8" title="1">iter := tr.GetRange(r, fdb.RangeOptions{Mode: fdb.StreamingModeWantAll}).Iterator()

                for iter.Advance() </span><span class="cov8" title="1">{
                        kv, err := iter.Get()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">var details models.BackupDetails
                        if err := deserialize(kv.Value, &amp;details); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Filter by TableName if requested
                        <span class="cov8" title="1">if request.TableName != "" </span><span class="cov8" title="1">{
                                expectedSegment := fmt.Sprintf("table/%s/backup/", request.TableName)
                                if !strings.Contains(details.BackupArn, expectedSegment) </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                        }

                        // Time Range Filtering (if implemented, but ignoring for now as per test)

                        <span class="cov8" title="1">summaries = append(summaries, models.BackupSummary{
                                BackupArn:              details.BackupArn,
                                BackupName:             details.BackupName,
                                BackupStatus:           details.BackupStatus,
                                BackupType:             details.BackupType,
                                BackupCreationDateTime: details.BackupCreationDateTime,
                                BackupSizeBytes:        details.BackupSizeBytes,
                                // TableName: ... we could extract it back
                        })

                        lastKey = details.BackupArn

                        if request.Limit &gt; 0 &amp;&amp; len(summaries) &gt;= request.Limit </span><span class="cov8" title="1">{
                                break</span>
                        }
                }

                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">var lastEvaluatedBackupArn string
        if request.Limit &gt; 0 &amp;&amp; len(summaries) &gt;= request.Limit </span><span class="cov8" title="1">{
                lastEvaluatedBackupArn = lastKey
        }</span>

        <span class="cov8" title="1">return summaries, lastEvaluatedBackupArn, nil</span>
}

func (s *FoundationDBStore) DeleteBackup(ctx context.Context, backupArn string) (*models.BackupDescription, error) <span class="cov8" title="1">{
        desc, err := s.DescribeBackup(ctx, backupArn)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                metaDir, err := s.getBackupMetadataDir(tr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tr.Clear(metaDir.Pack(tuple.Tuple{backupArn}))

                s.dir.Remove(tr, []string{"backups", "data", backupArn})
                return nil, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">desc.BackupDetails.BackupStatus = "DELETED"
        return desc, nil</span>
}

func (s *FoundationDBStore) DescribeBackup(ctx context.Context, backupArn string) (*models.BackupDescription, error) <span class="cov8" title="1">{
        var details models.BackupDetails
        var found bool

        _, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                metaDir, err := s.getBackupMetadataDir(tr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">valBytes, err := tr.Get(metaDir.Pack(tuple.Tuple{backupArn})).Get()
                if err != nil || valBytes == nil </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">found = true
                return nil, deserialize(valBytes, &amp;details)</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return nil, models.New("ResourceNotFoundException", "Backup not found")
        }</span>

        <span class="cov8" title="1">return &amp;models.BackupDescription{
                BackupDetails: details,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package store

import (
        "context"
        "encoding/json"
        "time"

        "github.com/apple/foundationdb/bindings/go/src/fdb"
        "github.com/apple/foundationdb/bindings/go/src/fdb/tuple"
        "github.com/tabeth/concretedb/models"
        "github.com/tabeth/concretedb/store/internal/fdbadapter"
)

// UpdateContinuousBackups enables or disables PITR for a table.
func (s *FoundationDBStore) UpdateContinuousBackups(ctx context.Context, req *models.UpdateContinuousBackupsRequest) (*models.ContinuousBackupsDescription, error) <span class="cov8" title="1">{
        val, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // 1. Get Table Metadata (Internal)
                table, err := s.getTableInternal(tr, req.TableName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>

                // 2. Open Table Directory
                <span class="cov8" title="1">tableDir, err := s.dir.Open(tr, []string{"tables", req.TableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 3. Determine new status
                <span class="cov8" title="1">status := "DISABLED"
                if req.PointInTimeRecoverySpecification.PointInTimeRecoveryEnabled </span><span class="cov8" title="1">{
                        status = "ENABLED"
                }</span>

                // 4. Calculate Timestamps
                <span class="cov8" title="1">earliestTime := 0.0
                if status == "ENABLED" </span><span class="cov8" title="1">{
                        // In a real system, if it was already enabled, we keep the old earliest time.
                        // Checking existing config is better.
                        existingConfigBytes, err := tr.Get(tableDir.Pack(tuple.Tuple{"pitr_config"})).Get()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if existingConfigBytes != nil </span><span class="cov8" title="1">{
                                var existingConfig models.PointInTimeRecoveryDescription
                                if err := json.Unmarshal(existingConfigBytes, &amp;existingConfig); err == nil </span><span class="cov0" title="0">{
                                        if existingConfig.PointInTimeRecoveryStatus == "ENABLED" </span><span class="cov0" title="0">{
                                                earliestTime = existingConfig.EarliestRestorableDateTime
                                        }</span> else<span class="cov0" title="0"> {
                                                earliestTime = float64(time.Now().UnixNano()) / 1e9
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        // Corrupt or new? assume new
                                        earliestTime = float64(time.Now().UnixNano()) / 1e9
                                }</span>
                        } else<span class="cov8" title="1"> {
                                earliestTime = float64(time.Now().UnixNano()) / 1e9
                        }</span>
                }

                <span class="cov8" title="1">pitrConfig := models.PointInTimeRecoveryDescription{
                        PointInTimeRecoveryStatus:  status,
                        EarliestRestorableDateTime: earliestTime,
                        LatestRestorableDateTime:   float64(time.Now().UnixNano()) / 1e9,
                }

                pitrBytes, err := json.Marshal(pitrConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">tr.Set(tableDir.Pack(tuple.Tuple{"pitr_config"}), pitrBytes)

                return &amp;models.ContinuousBackupsDescription{
                        ContinuousBackupsStatus:        "ENABLED",
                        PointInTimeRecoveryDescription: &amp;pitrConfig,
                }, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return val.(*models.ContinuousBackupsDescription), nil</span>
}

// DescribeContinuousBackups returns the PITR status.
func (s *FoundationDBStore) DescribeContinuousBackups(ctx context.Context, tableName string) (*models.ContinuousBackupsDescription, error) <span class="cov8" title="1">{
        val, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // 1. Get Table Metadata to ensure existence
                table, err := s.getTableInternal(rtr, tableName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>

                // 2. Open Table Directory
                <span class="cov8" title="1">tableDir, err := s.dir.Open(rtr, []string{"tables", tableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 3. Read PITR config
                <span class="cov8" title="1">pitrBytes, err := rtr.Get(tableDir.Pack(tuple.Tuple{"pitr_config"})).Get()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">desc := &amp;models.PointInTimeRecoveryDescription{
                        PointInTimeRecoveryStatus: "DISABLED",
                }

                if pitrBytes != nil </span><span class="cov8" title="1">{
                        if err := json.Unmarshal(pitrBytes, desc); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        // Update LatestRestorableDateTime to now if enabled
                        <span class="cov8" title="1">if desc.PointInTimeRecoveryStatus == "ENABLED" </span><span class="cov8" title="1">{
                                desc.LatestRestorableDateTime = float64(time.Now().UnixNano()) / 1e9
                        }</span>
                }

                <span class="cov8" title="1">return &amp;models.ContinuousBackupsDescription{
                        ContinuousBackupsStatus:        "ENABLED",
                        PointInTimeRecoveryDescription: desc,
                }, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return val.(*models.ContinuousBackupsDescription), nil</span>
}

// RestoreTableToPointInTime restores a table to a specific timestamp.
func (s *FoundationDBStore) RestoreTableToPointInTime(ctx context.Context, req *models.RestoreTableToPointInTimeRequest) (*models.TableDescription, error) <span class="cov8" title="1">{
        // 1. Check source table description (reusing public method is fine here as it's the entry point)
        desc, err := s.DescribeContinuousBackups(ctx, req.SourceTableName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if desc.PointInTimeRecoveryDescription == nil || desc.PointInTimeRecoveryDescription.PointInTimeRecoveryStatus != "ENABLED" </span><span class="cov8" title="1">{
                return nil, models.New("ValidationException", "Point-in-time recovery is not enabled for this table")
        }</span>

        // 2. Time Validation logic
        <span class="cov8" title="1">restoreTime := req.RestoreDateTime
        if req.UseLatestRestorableTime </span><span class="cov0" title="0">{
                restoreTime = desc.PointInTimeRecoveryDescription.LatestRestorableDateTime
        }</span>
        <span class="cov8" title="1">if restoreTime &lt; desc.PointInTimeRecoveryDescription.EarliestRestorableDateTime </span><span class="cov8" title="1">{
                return nil, models.New("ValidationException", "Restore time is before earliest restorable time")
        }</span>
        // Allow small clock skew loop? For now, strict check.
        // if restoreTime &gt; desc.PointInTimeRecoveryDescription.LatestRestorableDateTime {
        //          return nil, models.New("ValidationException", "Restore time is in the future")
        // }

        // 3. Check Target Table (must not exist)
        <span class="cov8" title="1">targetTableExists, err := s.GetTable(ctx, req.TargetTableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if targetTableExists != nil </span><span class="cov8" title="1">{
                return nil, models.New("ResourceInUseException", "Target table already exists")
        }</span>

        // 4. Create Target Table
        <span class="cov8" title="1">sourceTable, err := s.GetTable(ctx, req.SourceTableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">targetTable := *sourceTable
        targetTable.TableName = req.TargetTableName
        targetTable.Status = models.StatusCreating
        targetTable.CreationDateTime = time.Now()
        targetTable.GlobalSecondaryIndexes = make([]models.GlobalSecondaryIndex, len(sourceTable.GlobalSecondaryIndexes))
        copy(targetTable.GlobalSecondaryIndexes, sourceTable.GlobalSecondaryIndexes)
        targetTable.LocalSecondaryIndexes = make([]models.LocalSecondaryIndex, len(sourceTable.LocalSecondaryIndexes))
        copy(targetTable.LocalSecondaryIndexes, sourceTable.LocalSecondaryIndexes)

        // Since we are restoring, we must create the new table first
        if err := s.CreateTable(ctx, &amp;targetTable); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. Start Restore Async (Actually Synchronous for now to Ensure consistency in tests)
        <span class="cov8" title="1">s.performPointInTimeRestore(req.SourceTableName, req.TargetTableName, restoreTime)

        return &amp;models.TableDescription{
                TableName:             targetTable.TableName,
                TableStatus:           string(models.StatusCreating),
                AttributeDefinitions:  targetTable.AttributeDefinitions,
                KeySchema:             targetTable.KeySchema,
                CreationDateTime:      float64(targetTable.CreationDateTime.Unix()),
                ItemCount:             0,
                TableSizeBytes:        0,
                ProvisionedThroughput: targetTable.ProvisionedThroughput,
        }, nil</span>
}

var pitrBatchSize = 1000

func (s *FoundationDBStore) performPointInTimeRestore(sourceTableName, targetTableName string, restoreTime float64) <span class="cov8" title="1">{
        // Target Timestamp in Nanoseconds
        idxTime := int64(restoreTime * 1e9)

        var lastKeyProcessed fdb.Key
        batchSize := pitrBatchSize

        for </span><span class="cov8" title="1">{
                // New Transaction for each batch (or read loop)
                processedCount := 0

                val, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                        processedCount = 0

                        // 1. Open Directories
                        sourceHistoryDir, err := s.dir.Open(tr, []string{"tables", sourceTableName, "history"}, nil)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">targetDataDir, err := s.dir.Open(tr, []string{"tables", targetTableName}, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">targetTable, err := s.getTableInternal(tr, targetTableName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // 2. Scan History
                        // We want all keys.
                        <span class="cov8" title="1">beginKey, endKey := sourceHistoryDir.FDBRangeKeys()
                        r := fdb.KeyRange{Begin: beginKey, End: endKey}
                        if lastKeyProcessed != nil </span><span class="cov8" title="1">{
                                r.Begin = fdb.Key(append(lastKeyProcessed, 0x00))
                        }</span>

                        <span class="cov8" title="1">iter := tr.GetRange(r, fdb.RangeOptions{Mode: fdb.StreamingModeWantAll, Limit: batchSize}).Iterator()

                        // State for current PK processing
                        var currentPK []tuple.TupleElement
                        var bestCandidateItem map[string]models.AttributeValue
                        var bestCandidateIsDeleted bool
                        var candidateFound bool

                        historyPrefix := sourceHistoryDir.Bytes()

                        // Helper to finalize a PK
                        finalizePK := func(pk []tuple.TupleElement, item map[string]models.AttributeValue, deleted bool) </span><span class="cov8" title="1">{
                                if !candidateFound </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov8" title="1">if deleted </span><span class="cov0" title="0">{
                                        return
                                }</span> // effectively deleted at T

                                <span class="cov8" title="1">targetKey := targetDataDir.Pack(append(tuple.Tuple{"data"}, pk...))

                                // Serialize item
                                data, err := json.Marshal(item)
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov8" title="1">if len(data) == 0 </span>{<span class="cov0" title="0">
                                        // Empty data, should not happen for valid items
                                }</span>
                                <span class="cov8" title="1">tr.Set(targetKey, data)

                                // Update Indexes
                                err = s.updateIndexes(tr, targetTable, nil, item)
                                if err != nil </span>{<span class="cov0" title="0">
                                        // log error?
                                }</span>
                        }

                        <span class="cov8" title="1">var lastSafeResumeKey fdb.Key
                        var prevKey fdb.Key

                        for iter.Advance() </span><span class="cov8" title="1">{
                                processedCount++
                                kv, err := iter.Get()
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                // Parse Key
                                <span class="cov8" title="1">if len(kv.Key) &lt; len(historyPrefix) </span><span class="cov0" title="0">{
                                        prevKey = kv.Key
                                        continue</span>
                                }
                                <span class="cov8" title="1">suffix := kv.Key[len(historyPrefix):]
                                t, err := tuple.Unpack(suffix)
                                if err != nil </span><span class="cov0" title="0">{
                                        prevKey = kv.Key
                                        continue</span>
                                }

                                // Check tuple format: (PK..., Timestamp)
                                <span class="cov8" title="1">if len(t) &lt; 2 </span><span class="cov0" title="0">{
                                        prevKey = kv.Key
                                        continue</span>
                                } // Should have at least 1 PK part + Timestamp

                                <span class="cov8" title="1">tsVal := t[len(t)-1]
                                pkTuple := t[:len(t)-1]

                                ts, ok := tsVal.(int64)
                                if !ok </span><span class="cov0" title="0">{
                                        prevKey = kv.Key
                                        continue</span>
                                } // Should be int64

                                // Check if PK changed
                                <span class="cov8" title="1">pkChanged := false
                                if len(currentPK) == 0 </span><span class="cov8" title="1">{
                                        currentPK = pkTuple
                                }</span> else<span class="cov8" title="1"> {
                                        // Using packing for reliable comparison
                                        bpk1 := tuple.Tuple(currentPK).Pack()
                                        bpk2 := tuple.Tuple(pkTuple).Pack()
                                        if string(bpk1) != string(bpk2) </span><span class="cov8" title="1">{
                                                pkChanged = true
                                        }</span>
                                }

                                <span class="cov8" title="1">if pkChanged </span><span class="cov8" title="1">{
                                        // Finalize old
                                        finalizePK(currentPK, bestCandidateItem, bestCandidateIsDeleted)

                                        // Update safe resume key to the last record of the previous PK
                                        lastSafeResumeKey = prevKey

                                        // Reset
                                        currentPK = pkTuple
                                        bestCandidateItem = nil
                                        bestCandidateIsDeleted = false
                                        candidateFound = false
                                }</span>

                                // Process this record
                                <span class="cov8" title="1">if ts &lt;= idxTime </span><span class="cov8" title="1">{
                                        // candidate
                                        type HistoryRecord struct {
                                                Deleted bool                             `json:"deleted"`
                                                Item    map[string]models.AttributeValue `json:"item,omitempty"`
                                        }
                                        var rec HistoryRecord
                                        if err := json.Unmarshal(kv.Value, &amp;rec); err == nil </span><span class="cov8" title="1">{
                                                bestCandidateItem = rec.Item
                                                bestCandidateIsDeleted = rec.Deleted
                                                candidateFound = true
                                        }</span>
                                }

                                <span class="cov8" title="1">prevKey = kv.Key</span>
                        }

                        <span class="cov8" title="1">hitLimit := processedCount &gt;= batchSize

                        if !hitLimit </span><span class="cov8" title="1">{
                                // EOF reached. Finalize pending.
                                finalizePK(currentPK, bestCandidateItem, bestCandidateIsDeleted)
                                return nil, nil // Done
                        }</span>

                        // If hit limit, resume from lastSafeResumeKey
                        <span class="cov8" title="1">if lastSafeResumeKey != nil </span><span class="cov8" title="1">{
                                return lastSafeResumeKey, nil
                        }</span>

                        // If we hit limit but haven't finalized ANY PK (one huge PK history),
                        // logic fails. For MVP, we just return prevKey (end of batch) and hope next batch picks up correct state?
                        // NO, state is lost between batches (currentPK, bestCandidateItem).
                        // Robust implementation requires passing state.
                        // Ideally we assume batchSize &gt; largest single-PK history size.
                        // Returning nil here would terminate loop, which is bad.
                        // Returning prevKey resumes &gt; prevKey, missing the rest of this PK's history?
                        // Or just skipping the rest of this PK?
                        // For now, return prevKey to ensure progress, even if this edge case is broken.
                        <span class="cov0" title="0">if prevKey != nil </span><span class="cov0" title="0">{
                                return prevKey, nil
                        }</span>

                        <span class="cov0" title="0">return nil, nil</span>
                })

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        s.setTableStatus(targetTableName, models.TableStatus("CREATING_FAILED"))
                        return
                }</span>

                <span class="cov8" title="1">if val == nil </span><span class="cov8" title="1">{
                        break</span> // Done
                }

                <span class="cov8" title="1">lastKeyProcessed = val.(fdb.Key)</span>
        }

        // Set status to ACTIVE
        <span class="cov8" title="1">s.setTableStatus(targetTableName, models.StatusActive)</span>
}

// writeHistoryRecord writes a historical version of an item if PITR is enabled.
func (s *FoundationDBStore) writeHistoryRecord(tr fdbadapter.FDBTransaction, table *models.Table, item map[string]models.AttributeValue, deleteMarker bool) error <span class="cov8" title="1">{
        // 1. Check if PITR is enabled for this table
        tableDir, err := s.dir.Open(tr, []string{"tables", table.TableName}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pitrConfigBytes, err := tr.Get(tableDir.Pack(tuple.Tuple{"pitr_config"})).Get()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if pitrConfigBytes == nil </span><span class="cov8" title="1">{
                return nil // Not enabled
        }</span>

        <span class="cov8" title="1">var config models.PointInTimeRecoveryDescription
        if err := json.Unmarshal(pitrConfigBytes, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil // Ignore corrupt config
        }</span>

        <span class="cov8" title="1">if config.PointInTimeRecoveryStatus != "ENABLED" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // 2. Construct History Key
        <span class="cov8" title="1">keyTuple, err := s.buildKeyTuple(table, item)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Open history subspace
        <span class="cov8" title="1">historyDir, err := s.dir.CreateOrOpen(tr, []string{"tables", table.TableName, "history"}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Timestamp: Unix Nanoseconds
        <span class="cov8" title="1">ts := time.Now().UnixNano()

        // Key structure: historyDir + (PK..., Timestamp)
        fullTuple := append(keyTuple, ts)
        historyKey := historyDir.Pack(fullTuple)

        // 3. Prepare Value
        type HistoryRecord struct {
                Deleted bool                             `json:"deleted"`
                Item    map[string]models.AttributeValue `json:"item,omitempty"`
        }

        record := HistoryRecord{
                Deleted: deleteMarker,
                Item:    item,
        }

        data, err := json.Marshal(record)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tr.Set(historyKey, data)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package store

import (
        "context"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/apple/foundationdb/bindings/go/src/fdb"
        "github.com/apple/foundationdb/bindings/go/src/fdb/subspace"
        "github.com/apple/foundationdb/bindings/go/src/fdb/tuple"
        "github.com/google/uuid"
        "github.com/tabeth/concretedb/expression"
        "github.com/tabeth/concretedb/models"
        "github.com/tabeth/concretedb/store/internal/fdbadapter"
        "github.com/tabeth/kiroku-core/libs/fdb/directory"
)

// FoundationDBStore implements the Store interface using FoundationDB.
type FoundationDBStore struct {
        db        fdbadapter.FDBDatabase
        dir       fdbadapter.DirectoryProvider
        evaluator *expression.Evaluator
}

// NewFoundationDBStore creates a new store connected to FoundationDB.
func NewFoundationDBStore(db fdb.Database) *FoundationDBStore <span class="cov8" title="1">{
        fmt.Println("Creating FDB store.")
        return &amp;FoundationDBStore{
                db:        fdbadapter.NewRealFDBDatabase(db),
                dir:       fdbadapter.NewRealDirectoryProvider(directory.NewDirectoryLayer(subspace.Sub(tuple.Tuple{"concretedb"}), subspace.Sub(tuple.Tuple{"content"}), true)),
                evaluator: expression.NewEvaluator(),
        }
}</span>

// Scan scans the table.
func (s *FoundationDBStore) Scan(ctx context.Context, tableName string, filterExpression string, projectionExpression string, expressionAttributeNames map[string]string, expressionAttributeValues map[string]models.AttributeValue, limit int32, exclusiveStartKey map[string]models.AttributeValue, consistentRead bool) ([]map[string]models.AttributeValue, map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        // First check table metadata existence (consistency check)
        table, err := s.GetTable(ctx, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrTableNotFound
        }</span>

        <span class="cov8" title="1">res, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // Open the directory for this table
                tableDir, err := s.dir.Open(rtr, []string{"tables", tableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Determine Range
                <span class="cov8" title="1">var r fdb.Range
                if len(exclusiveStartKey) &gt; 0 </span><span class="cov8" title="1">{
                        keyTuple, err := s.buildKeyTuple(table, exclusiveStartKey)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">startFDBKey := tableDir.Pack(append(tuple.Tuple{"data"}, keyTuple...))
                        // Start reading *after* the exclusive start key
                        // Note: We need the end of the data range for this table.
                        dataPrefix := tableDir.Pack(tuple.Tuple{"data"})
                        pr, _ := fdb.PrefixRange(dataPrefix)

                        r = fdb.SelectorRange{
                                Begin: fdb.FirstGreaterThan(startFDBKey),
                                End:   fdb.FirstGreaterOrEqual(pr.End),
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Scan the entire "data" subspace for the table
                        dataPrefix := tableDir.Pack(tuple.Tuple{"data"})
                        r, _ = fdb.PrefixRange(dataPrefix)
                }</span>

                // Options
                <span class="cov8" title="1">opts := fdb.RangeOptions{}
                if limit &gt; 0 </span><span class="cov8" title="1">{
                        opts.Limit = int(limit)
                }</span>

                // Perform Range Read
                <span class="cov8" title="1">iter := rtr.GetRange(r, opts).Iterator()

                var items []map[string]models.AttributeValue
                var lastProcessedItem map[string]models.AttributeValue
                var itemsRead int

                for iter.Advance() </span><span class="cov8" title="1">{
                        kv, err := iter.Get()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Deserialize value
                        <span class="cov8" title="1">var item map[string]models.AttributeValue
                        if len(kv.Value) &gt; 0 </span><span class="cov8" title="1">{
                                if err := json.Unmarshal(kv.Value, &amp;item); err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("failed to unmarshal item: %w", err)
                                }</span>

                                <span class="cov8" title="1">lastProcessedItem = item
                                itemsRead++

                                // Evaluate Filter
                                match, err := s.evaluator.EvaluateFilter(item, filterExpression, expressionAttributeNames, expressionAttributeValues)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                                        // Apply Projection
                                        item = s.evaluator.ProjectItem(item, projectionExpression, expressionAttributeNames)
                                        items = append(items, item)
                                }</span>
                        }
                }

                // Handle pagination
                <span class="cov8" title="1">var lastEvaluatedKey map[string]models.AttributeValue
                if limit &gt; 0 &amp;&amp; itemsRead == int(limit) &amp;&amp; lastProcessedItem != nil </span><span class="cov8" title="1">{
                        lastEvaluatedKey = make(map[string]models.AttributeValue)
                        for _, ks := range table.KeySchema </span><span class="cov8" title="1">{
                                if val, ok := lastProcessedItem[ks.AttributeName]; ok </span><span class="cov8" title="1">{
                                        lastEvaluatedKey[ks.AttributeName] = val
                                }</span>
                        }
                }

                <span class="cov8" title="1">return struct {
                        Items   []map[string]models.AttributeValue
                        LastKey map[string]models.AttributeValue
                }{items, lastEvaluatedKey}, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">result := res.(struct {
                Items   []map[string]models.AttributeValue
                LastKey map[string]models.AttributeValue
        })
        return result.Items, result.LastKey, nil</span>
}

// Query queries the table.
func (s *FoundationDBStore) Query(ctx context.Context, tableName string, indexName string, keyConditionExpression string, filterExpression string, projectionExpression string, expressionAttributeNames map[string]string, expressionAttributeValues map[string]models.AttributeValue, limit int32, exclusiveStartKey map[string]models.AttributeValue, consistentRead bool) ([]map[string]models.AttributeValue, map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        // 1. Get Table Metadata
        table, err := s.GetTable(ctx, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrTableNotFound
        }</span>

        // 2. Determine Key Schema (Table or Index)
        <span class="cov8" title="1">targetKeySchema := table.KeySchema
        if indexName != "" </span><span class="cov8" title="1">{
                found := false
                // check GSI
                for _, gsi := range table.GlobalSecondaryIndexes </span><span class="cov8" title="1">{
                        if gsi.IndexName == indexName </span><span class="cov8" title="1">{
                                targetKeySchema = gsi.KeySchema
                                found = true
                                break</span>
                        }
                }
                // check LSI
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        for _, lsi := range table.LocalSecondaryIndexes </span><span class="cov8" title="1">{
                                if lsi.IndexName == indexName </span><span class="cov8" title="1">{
                                        targetKeySchema = lsi.KeySchema
                                        found = true
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("index not found: %s", indexName)
                }</span>
        }

        // 3. Parse Key Condition
        <span class="cov8" title="1">var pkHashName, pkRangeName string
        for _, k := range targetKeySchema </span><span class="cov8" title="1">{
                if k.KeyType == "HASH" </span><span class="cov8" title="1">{
                        pkHashName = k.AttributeName
                }</span> else<span class="cov8" title="1"> if k.KeyType == "RANGE" </span><span class="cov8" title="1">{
                        pkRangeName = k.AttributeName
                }</span>
        }
        <span class="cov8" title="1">if pkHashName == "" </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("invalid schema: no HASH key")
        }</span>

        // Simple Parser Logic (reused)
        <span class="cov8" title="1">rawParts := strings.Split(keyConditionExpression, " AND ")
        var parts []string
        for i := 0; i &lt; len(rawParts); i++ </span><span class="cov8" title="1">{
                p := rawParts[i]
                if strings.Contains(p, "BETWEEN") </span><span class="cov8" title="1">{
                        if i+1 &lt; len(rawParts) </span><span class="cov8" title="1">{
                                p = p + " AND " + rawParts[i+1]
                                i++
                        }</span>
                }
                <span class="cov8" title="1">parts = append(parts, p)</span>
        }

        <span class="cov8" title="1">var pkValue *models.AttributeValue
        var skOp string
        var skVals []*models.AttributeValue

        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                if strings.Contains(part, pkHashName) &amp;&amp; strings.Contains(part, "=") </span><span class="cov8" title="1">{
                        subParts := strings.SplitN(part, "=", 2)
                        if len(subParts) == 2 </span><span class="cov8" title="1">{
                                valPlaceholder := strings.TrimSpace(subParts[1])
                                if v, ok := expressionAttributeValues[valPlaceholder]; ok </span><span class="cov8" title="1">{
                                        val := v
                                        pkValue = &amp;val
                                }</span>
                        }
                } else<span class="cov8" title="1"> if pkRangeName != "" &amp;&amp; strings.Contains(part, pkRangeName) </span><span class="cov8" title="1">{
                        // SK Conditions
                        if strings.HasPrefix(part, "begins_with") </span><span class="cov8" title="1">{
                                skOp = "begins_with"
                                start := strings.Index(part, ",")
                                end := strings.Index(part, ")")
                                if start &gt; 0 &amp;&amp; end &gt; start </span><span class="cov8" title="1">{
                                        valPlaceholder := strings.TrimSpace(part[start+1 : end])
                                        if v, ok := expressionAttributeValues[valPlaceholder]; ok </span><span class="cov8" title="1">{
                                                val := v
                                                skVals = append(skVals, &amp;val)
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                ops := []string{"&lt;=", "&gt;=", "&lt;", "&gt;", "=", "BETWEEN", "IN"}
                                foundOp := ""
                                for _, op := range ops </span><span class="cov8" title="1">{
                                        if strings.Contains(part, op) </span><span class="cov8" title="1">{
                                                foundOp = op
                                                break</span>
                                        }
                                }
                                // Robust search
                                <span class="cov8" title="1">if strings.Contains(part, "&lt;=") </span><span class="cov8" title="1">{
                                        foundOp = "&lt;="
                                }</span> else<span class="cov8" title="1"> if strings.Contains(part, "&gt;=") </span><span class="cov8" title="1">{
                                        foundOp = "&gt;="
                                }</span> else<span class="cov8" title="1"> if strings.Contains(part, "&lt;") </span><span class="cov8" title="1">{
                                        foundOp = "&lt;"
                                }</span> else<span class="cov8" title="1"> if strings.Contains(part, "&gt;") </span><span class="cov8" title="1">{
                                        foundOp = "&gt;"
                                }</span> else<span class="cov8" title="1"> if strings.Contains(part, "=") </span><span class="cov8" title="1">{
                                        foundOp = "="
                                }</span> else<span class="cov8" title="1"> if strings.Contains(part, "BETWEEN") </span><span class="cov8" title="1">{
                                        foundOp = "BETWEEN"
                                }</span>

                                <span class="cov8" title="1">if foundOp != "" </span><span class="cov8" title="1">{
                                        skOp = foundOp
                                        sub := strings.SplitN(part, foundOp, 2)
                                        if len(sub) == 2 </span><span class="cov8" title="1">{
                                                rhs := strings.TrimSpace(sub[1])
                                                if foundOp == "BETWEEN" </span><span class="cov8" title="1">{
                                                        betweens := strings.Split(rhs, " AND ")
                                                        if len(betweens) == 2 </span><span class="cov8" title="1">{
                                                                v1 := strings.TrimSpace(betweens[0])
                                                                v2 := strings.TrimSpace(betweens[1])
                                                                if val1, ok := expressionAttributeValues[v1]; ok </span><span class="cov8" title="1">{
                                                                        val := val1
                                                                        skVals = append(skVals, &amp;val)
                                                                }</span>
                                                                <span class="cov8" title="1">if val2, ok := expressionAttributeValues[v2]; ok </span><span class="cov8" title="1">{
                                                                        val := val2
                                                                        skVals = append(skVals, &amp;val)
                                                                }</span>
                                                        }
                                                } else<span class="cov8" title="1"> {
                                                        if v, ok := expressionAttributeValues[rhs]; ok </span><span class="cov8" title="1">{
                                                                val := v
                                                                skVals = append(skVals, &amp;val)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">if pkValue == nil </span><span class="cov8" title="1">{
                if len(expressionAttributeValues) == 1 </span><span class="cov8" title="1">{
                        for _, v := range expressionAttributeValues </span><span class="cov8" title="1">{
                                val := v
                                pkValue = &amp;val
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if pkValue == nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("could not resolve Partition Key value")
        }</span>

        <span class="cov8" title="1">res, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                var subspace fdbadapter.FDBDirectorySubspace
                var err error
                if indexName != "" </span><span class="cov8" title="1">{
                        // Index Query: Key is (indexPK, ..., indexSK, ...)
                        subspace, err = s.dir.Open(rtr, []string{"tables", tableName, "index", indexName}, nil)
                }</span> else<span class="cov8" title="1"> {
                        // Base Table Query: Key is ("data", pk, sk)
                        subspace, err = s.dir.Open(rtr, []string{"tables", tableName}, nil)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">pkTupleElem, err := toTupleElement(*pkValue)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">var prefixKey fdb.Key
                if indexName != "" </span><span class="cov8" title="1">{
                        prefixKey = subspace.Pack(tuple.Tuple{pkTupleElem})
                }</span> else<span class="cov8" title="1"> {
                        prefixKey = subspace.Pack(tuple.Tuple{"data", pkTupleElem})
                }</span>
                <span class="cov8" title="1">pr, err := fdb.PrefixRange(prefixKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">r := fdb.SelectorRange{
                        Begin: fdb.FirstGreaterOrEqual(pr.Begin),
                        End:   fdb.FirstGreaterOrEqual(pr.End),
                }

                if skOp != "" &amp;&amp; len(skVals) &gt; 0 </span><span class="cov8" title="1">{
                        getSKKey := func(val *models.AttributeValue) (fdb.Key, error) </span><span class="cov8" title="1">{
                                tElem, err := toTupleElement(*val)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">if indexName != "" </span><span class="cov8" title="1">{
                                        return subspace.Pack(tuple.Tuple{pkTupleElem, tElem}), nil
                                }</span>
                                <span class="cov8" title="1">return subspace.Pack(tuple.Tuple{"data", pkTupleElem, tElem}), nil</span>
                        }
                        <span class="cov8" title="1">switch skOp </span>{
                        case "=":<span class="cov8" title="1">
                                k, _ := getSKKey(skVals[0])
                                pr, _ := fdb.PrefixRange(k)
                                r.Begin = fdb.FirstGreaterOrEqual(pr.Begin)
                                r.End = fdb.FirstGreaterOrEqual(pr.End)</span>
                        case "&lt;":<span class="cov8" title="1">
                                k, _ := getSKKey(skVals[0])
                                r.End = fdb.FirstGreaterOrEqual(k)</span>
                        case "&lt;=":<span class="cov8" title="1">
                                k, _ := getSKKey(skVals[0])
                                pr, _ := fdb.PrefixRange(k)
                                r.End = fdb.FirstGreaterOrEqual(pr.End)</span>
                        case "&gt;":<span class="cov8" title="1">
                                k, _ := getSKKey(skVals[0])
                                pr, _ := fdb.PrefixRange(k)
                                r.Begin = fdb.FirstGreaterOrEqual(pr.End)</span>
                        case "&gt;=":<span class="cov8" title="1">
                                k, _ := getSKKey(skVals[0])
                                r.Begin = fdb.FirstGreaterOrEqual(k)</span>
                        case "BETWEEN":<span class="cov8" title="1">
                                if len(skVals) &gt;= 2 </span><span class="cov8" title="1">{
                                        k1, _ := getSKKey(skVals[0])
                                        k2, _ := getSKKey(skVals[1])
                                        pr2, _ := fdb.PrefixRange(k2)
                                        r.Begin = fdb.FirstGreaterOrEqual(k1)
                                        r.End = fdb.FirstGreaterOrEqual(pr2.End)
                                }</span>
                        case "begins_with":<span class="cov8" title="1">
                                skVal := skVals[0]
                                if skVal.S != nil </span><span class="cov8" title="1">{
                                        k1, _ := getSKKey(skVal)
                                        str := *skVal.S
                                        strNext := str + "\x00"
                                        for i := len(str) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                                if str[i] &lt; 0xff </span><span class="cov8" title="1">{
                                                        strNext = str[:i] + string(str[i]+1)
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">avNext := models.AttributeValue{S: &amp;strNext}
                                        k2, _ := getSKKey(&amp;avNext)
                                        r.Begin = fdb.FirstGreaterOrEqual(k1)
                                        r.End = fdb.FirstGreaterOrEqual(k2)</span>
                                } else<span class="cov8" title="1"> {
                                        return nil, fmt.Errorf("begins_with SK must be string")
                                }</span>
                        default:<span class="cov8" title="1">
                                return nil, fmt.Errorf("unsupported SK operator: %s", skOp)</span>
                        }
                }

                <span class="cov8" title="1">if len(exclusiveStartKey) &gt; 0 </span><span class="cov8" title="1">{
                        var keyTuple []tuple.TupleElement
                        var err error
                        if indexName != "" </span><span class="cov8" title="1">{
                                kt, err := s.buildIndexKeyTuple(table, targetKeySchema, exclusiveStartKey)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">keyTuple = kt</span>
                        } else<span class="cov8" title="1"> {
                                keyTuple, err = s.buildKeyTuple(table, exclusiveStartKey)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>
                        }

                        <span class="cov8" title="1">if indexName != "" </span><span class="cov8" title="1">{
                                startFDBKey := subspace.Pack(keyTuple)
                                r.Begin = fdb.FirstGreaterThan(startFDBKey)
                        }</span> else<span class="cov8" title="1"> {
                                startFDBKey := subspace.Pack(append(tuple.Tuple{"data"}, keyTuple...))
                                r.Begin = fdb.FirstGreaterThan(startFDBKey)
                        }</span>
                }

                <span class="cov8" title="1">opts := fdb.RangeOptions{}
                if limit &gt; 0 </span><span class="cov8" title="1">{
                        opts.Limit = int(limit)
                }</span>
                <span class="cov8" title="1">iter := rtr.GetRange(r, opts).Iterator()

                var items []map[string]models.AttributeValue
                var lastProcessedItem map[string]models.AttributeValue
                var itemsRead int

                for iter.Advance() </span><span class="cov8" title="1">{
                        kv, err := iter.Get()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">var item map[string]models.AttributeValue
                        if len(kv.Value) &gt; 0 </span><span class="cov8" title="1">{
                                _ = json.Unmarshal(kv.Value, &amp;item)
                                lastProcessedItem = item
                                itemsRead++

                                match, err := s.evaluator.EvaluateFilter(item, filterExpression, expressionAttributeNames, expressionAttributeValues)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                                        item = s.evaluator.ProjectItem(item, projectionExpression, expressionAttributeNames)
                                        items = append(items, item)
                                }</span>
                        }
                }

                <span class="cov8" title="1">var lastEvaluatedKey map[string]models.AttributeValue
                if limit &gt; 0 &amp;&amp; itemsRead == int(limit) &amp;&amp; lastProcessedItem != nil </span><span class="cov8" title="1">{
                        lastEvaluatedKey = make(map[string]models.AttributeValue)
                        for _, ks := range table.KeySchema </span><span class="cov8" title="1">{
                                if val, ok := lastProcessedItem[ks.AttributeName]; ok </span><span class="cov8" title="1">{
                                        lastEvaluatedKey[ks.AttributeName] = val
                                }</span>
                        }
                }

                <span class="cov8" title="1">return struct {
                        Items   []map[string]models.AttributeValue
                        LastKey map[string]models.AttributeValue
                }{items, lastEvaluatedKey}, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">result := res.(struct {
                Items   []map[string]models.AttributeValue
                LastKey map[string]models.AttributeValue
        })
        return result.Items, result.LastKey, nil</span>
}

// CreateTable persists a new table's metadata within a FoundationDB transaction.
func (s *FoundationDBStore) CreateTable(ctx context.Context, table *models.Table) error <span class="cov8" title="1">{
        if table.TableName == "" </span><span class="cov8" title="1">{
                return models.New("ValidationException", "TableName cannot be empty")
        }</span>
        <span class="cov8" title="1">fmt.Println("Creating table :", table.TableName)
        _, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // Simulating instant provisioning for ConcreteDB
                if table.Status == "" </span><span class="cov8" title="1">{
                        table.Status = models.StatusActive
                }</span>

                <span class="cov8" title="1">if table.StreamSpecification != nil &amp;&amp; table.StreamSpecification.StreamEnabled </span><span class="cov8" title="1">{
                        now := time.Now().UTC()
                        label := now.Format("2006-01-02T15:04:05.000")
                        table.LatestStreamLabel = label
                        table.LatestStreamArn = fmt.Sprintf("arn:aws:dynamodb:local:000000000000:table/%s/stream/%s", table.TableName, label)
                }</span>

                // Marshal the table metadata to JSON
                <span class="cov8" title="1">tableBytes, err := json.Marshal(table)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Create or Open the directory for this table
                // Path: ["tables", tableName]
                // This allocates a unique prefix for the table's data
                <span class="cov8" title="1">tableDir, err := s.dir.CreateOrOpen(tr, []string{"tables", table.TableName}, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Use a specific key regarding metadata within that directory
                <span class="cov8" title="1">metaKey := tableDir.Pack(tuple.Tuple{"metadata"})

                // Check if it already has metadata (implies existence)
                // Note: CreateOrOpen is idempotent, effectively "GetOrConnect".
                // We explicitly check if metadata exists to enforce "ErrTableExists"
                existingVal, err := tr.Get(metaKey).Get()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if existingVal != nil </span><span class="cov8" title="1">{
                        return nil, ErrTableExists
                }</span>

                // Save metadata
                <span class="cov8" title="1">tr.Set(metaKey, tableBytes)

                // Create directories for GSIs
                for _, gsi := range table.GlobalSecondaryIndexes </span><span class="cov8" title="1">{
                        _, err := s.dir.CreateOrOpen(tr, []string{"tables", table.TableName, "index", gsi.IndexName}, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // Create directories for LSIs
                <span class="cov8" title="1">for _, lsi := range table.LocalSecondaryIndexes </span><span class="cov8" title="1">{
                        _, err := s.dir.CreateOrOpen(tr, []string{"tables", table.TableName, "index", lsi.IndexName}, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">return nil, nil</span>
        })
        <span class="cov8" title="1">return err</span>
}

// GetTable retrieves a table's metadata by name.
func (s *FoundationDBStore) GetTable(ctx context.Context, tableName string) (*models.Table, error) <span class="cov8" title="1">{
        val, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // Check if directory exists first
                exists, err := s.dir.Exists(rtr, []string{"tables", tableName})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>

                // Open the directory (read-only safe if exists)
                <span class="cov8" title="1">tableDir, err := s.dir.Open(rtr, []string{"tables", tableName}, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return rtr.Get(tableDir.Pack(tuple.Tuple{"metadata"})).Get()</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tableBytes, ok := val.([]byte)
        if !ok || len(tableBytes) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var table models.Table
        if err := json.Unmarshal(tableBytes, &amp;table); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;table, nil</span>
}

// UpdateTable updates a table's metadata (e.g. enabling streams).
func (s *FoundationDBStore) UpdateTable(ctx context.Context, request *models.UpdateTableRequest) (*models.Table, error) <span class="cov8" title="1">{
        val, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // 1. Get Table Metadata
                table, err := s.getTableInternal(tr, request.TableName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>

                // 1.5. Update AttributeDefinitions
                <span class="cov8" title="1">for _, newAttr := range request.AttributeDefinitions </span><span class="cov8" title="1">{
                        found := false
                        for i, existing := range table.AttributeDefinitions </span><span class="cov8" title="1">{
                                if existing.AttributeName == newAttr.AttributeName </span><span class="cov8" title="1">{
                                        table.AttributeDefinitions[i] = newAttr
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                table.AttributeDefinitions = append(table.AttributeDefinitions, newAttr)
                        }</span>
                }

                // 1.6 Process GSI Updates
                // Note: Robust implementation should validate schemas and backfill data.
                // For MVP, we metadata-only update and set status to ACTIVE.
                <span class="cov8" title="1">if len(request.GlobalSecondaryIndexUpdates) &gt; 0 </span><span class="cov8" title="1">{
                        for _, update := range request.GlobalSecondaryIndexUpdates </span><span class="cov8" title="1">{
                                if update.Create != nil </span><span class="cov8" title="1">{
                                        gsi := models.GlobalSecondaryIndex{
                                                IndexName:             update.Create.IndexName,
                                                KeySchema:             update.Create.KeySchema,
                                                Projection:            update.Create.Projection,
                                                ProvisionedThroughput: update.Create.ProvisionedThroughput,
                                                IndexStatus:           "ACTIVE",
                                        }
                                        table.GlobalSecondaryIndexes = append(table.GlobalSecondaryIndexes, gsi)
                                }</span>
                                // Handle Delete/Update as needed for completeness
                                <span class="cov8" title="1">if update.Delete != nil </span><span class="cov8" title="1">{
                                        newIndexes := []models.GlobalSecondaryIndex{}
                                        for _, existing := range table.GlobalSecondaryIndexes </span><span class="cov8" title="1">{
                                                if existing.IndexName != update.Delete.IndexName </span><span class="cov8" title="1">{
                                                        newIndexes = append(newIndexes, existing)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">table.GlobalSecondaryIndexes = newIndexes</span>
                                }
                        }
                }

                // 2. Process Stream Updates
                <span class="cov8" title="1">if request.StreamSpecification != nil </span><span class="cov8" title="1">{
                        if request.StreamSpecification.StreamEnabled </span><span class="cov8" title="1">{
                                if table.StreamSpecification == nil || !table.StreamSpecification.StreamEnabled </span><span class="cov8" title="1">{
                                        // Enabling stream
                                        now := time.Now().UTC()
                                        label := now.Format("2006-01-02T15:04:05.000")
                                        table.LatestStreamLabel = label
                                        table.LatestStreamArn = fmt.Sprintf("arn:aws:dynamodb:local:000000000000:table/%s/stream/%s", table.TableName, label)
                                }</span>
                                <span class="cov8" title="1">table.StreamSpecification = request.StreamSpecification</span>
                        } else<span class="cov8" title="1"> {
                                // Disabling stream
                                table.StreamSpecification = &amp;models.StreamSpecification{StreamEnabled: false}
                        }</span>
                }

                // 3. Save updated metadata
                <span class="cov8" title="1">tableBytes, err := json.Marshal(table)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">tableDir, err := s.dir.Open(tr, []string{"tables", table.TableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tr.Set(tableDir.Pack(tuple.Tuple{"metadata"}), tableBytes)

                return table, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return val.(*models.Table), nil</span>
}

func (s *FoundationDBStore) DeleteTable(ctx context.Context, tableName string) (*models.Table, error) <span class="cov8" title="1">{
        val, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // Check existence
                exists, err := s.dir.Exists(tr, []string{"tables", tableName})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>

                <span class="cov8" title="1">tableDir, err := s.dir.Open(tr, []string{"tables", tableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">metaKey := tableDir.Pack(tuple.Tuple{"metadata"})

                existingVal, err := tr.Get(metaKey).Get()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if existingVal == nil </span><span class="cov8" title="1">{
                        // Should strictly not happen if dir exists, but possible if inconsistent
                        return nil, ErrTableNotFound
                }</span>

                <span class="cov8" title="1">var table models.Table
                if err := json.Unmarshal(existingVal, &amp;table); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Mark as deleting (optional if we really delete it immediately, but good for return value)
                <span class="cov8" title="1">table.Status = models.StatusDeleting

                // Actually delete the directory (metadata + data)
                // This removes the prefix mapping and all data under it.
                if _, err := s.dir.Remove(tr, []string{"tables", tableName}); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return &amp;table, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return val.(*models.Table), nil</span>
}

func (s *FoundationDBStore) ListTables(ctx context.Context, limit int, exclusiveStartTableName string) ([]string, string, error) <span class="cov8" title="1">{
        fetchLimit := limit
        if fetchLimit &gt; 0 </span><span class="cov8" title="1">{
                fetchLimit++
        }</span> else<span class="cov8" title="1"> {
                fetchLimit = 101 // Default fetch size if none provided
        }</span>

        <span class="cov8" title="1">res, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                options := directory.ListOptions{
                        Limit: fetchLimit,
                        After: exclusiveStartTableName,
                }
                return s.dir.List(rtr, []string{"tables"}, options)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">tableNames := res.([]string)
        lastEvaluatedTableName := ""

        if limit &gt; 0 &amp;&amp; len(tableNames) &gt; limit </span><span class="cov8" title="1">{
                // We have more results than requested
                lastEvaluatedTableName = tableNames[limit-1]
                tableNames = tableNames[:limit]
        }</span> else<span class="cov8" title="1"> if len(tableNames) &gt; 0 </span><span class="cov8" title="1">{
                if limit == 0 &amp;&amp; len(tableNames) == 101 </span><span class="cov0" title="0">{
                        lastEvaluatedTableName = tableNames[100-1] // The 100th item is the last one we return
                        tableNames = tableNames[:100]
                }</span>
        }

        <span class="cov8" title="1">return tableNames, lastEvaluatedTableName, nil</span>
}

// PutItem writes an item to the table.
func (s *FoundationDBStore) PutItem(ctx context.Context, tableName string, item map[string]models.AttributeValue, conditionExpression string, exprAttrNames map[string]string, exprAttrValues map[string]models.AttributeValue, returnValues string) (map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        val, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // 1. Get Table Metadata
                table, err := s.getTableInternal(tr, tableName)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>

                <span class="cov8" title="1">return s.putItemInternal(tr, table, item, conditionExpression, exprAttrNames, exprAttrValues, returnValues)</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if val == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return val.(map[string]models.AttributeValue), nil</span>
}

func (s *FoundationDBStore) putItemInternal(tr fdbadapter.FDBTransaction, table *models.Table, item map[string]models.AttributeValue, conditionExpression string, exprAttrNames map[string]string, exprAttrValues map[string]models.AttributeValue, returnValues string) (map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        // 1. Extract Key Fields
        keyTuple, err := s.buildKeyTuple(table, item)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 2. Always fetch old item for index maintenance AND conditional checks
        <span class="cov8" title="1">oldItem, err := s.getItemInternal(tr, table, keyTuple)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 3. Conditional Check
        <span class="cov8" title="1">if conditionExpression != "" </span><span class="cov8" title="1">{
                // Ensure oldItem is not nil for evaluator
                evalItem := oldItem
                if evalItem == nil </span><span class="cov0" title="0">{
                        evalItem = make(map[string]models.AttributeValue)
                }</span>
                <span class="cov8" title="1">match, err := s.evaluator.EvaluateFilter(evalItem, conditionExpression, exprAttrNames, exprAttrValues)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if !match </span><span class="cov8" title="1">{
                        return nil, models.New("ConditionalCheckFailedException", "The conditional request failed")
                }</span>
        }

        // 4. Serialize Item
        <span class="cov8" title="1">itemBytes, err := json.Marshal(item)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 5. Store
        <span class="cov8" title="1">tableDir, err := s.dir.Open(tr, []string{"tables", table.TableName}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">itemKey := tableDir.Pack(append(tuple.Tuple{"data"}, keyTuple...))
        tr.Set(itemKey, itemBytes)

        // 6. Update Indexes
        if err := s.updateIndexes(tr, table, oldItem, item); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 7. Write to History (PITR)
        <span class="cov8" title="1">if err := s.writeHistoryRecord(tr, table, item, false); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 8. Stream Record
        <span class="cov8" title="1">eventName := "MODIFY"
        if oldItem == nil </span><span class="cov8" title="1">{
                eventName = "INSERT" // Or INSERT if oldItem was nil/empty
        }</span>
        <span class="cov8" title="1">if err := s.writeStreamRecord(tr, table, eventName, oldItem, item); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if returnValues == "ALL_OLD" </span><span class="cov8" title="1">{
                return oldItem, nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

// GetItem retrieves an item by key.
func (s *FoundationDBStore) GetItem(ctx context.Context, tableName string, key map[string]models.AttributeValue, projectionExpression string, expressionAttributeNames map[string]string, consistentRead bool) (map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        val, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // 1. Get Table Metadata
                table, err := s.getTableInternal(rtr, tableName)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>

                // 2. Extract Key Fields from the *request key map*
                <span class="cov8" title="1">keyTuple, err := s.buildKeyTuple(table, key)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // 3. Fetch
                <span class="cov8" title="1">item, err := s.getItemInternal(rtr, table, keyTuple)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return item, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if val == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">item := val.(map[string]models.AttributeValue)

        // 4. Apply Projection
        if projectionExpression != "" </span><span class="cov0" title="0">{
                item = s.evaluator.ProjectItem(item, projectionExpression, expressionAttributeNames)
        }</span>

        <span class="cov8" title="1">return item, nil</span>
}

// DeleteItem deletes an item by key.
func (s *FoundationDBStore) DeleteItem(ctx context.Context, tableName string, key map[string]models.AttributeValue, conditionExpression string, exprAttrNames map[string]string, exprAttrValues map[string]models.AttributeValue, returnValues string) (map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        val, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // 1. Get Table Metadata
                table, err := s.getTableInternal(tr, tableName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>

                <span class="cov8" title="1">return s.deleteItemInternal(tr, table, key, conditionExpression, exprAttrNames, exprAttrValues, returnValues)</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if val == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return val.(map[string]models.AttributeValue), nil</span>
}

func (s *FoundationDBStore) deleteItemInternal(tr fdbadapter.FDBTransaction, table *models.Table, key map[string]models.AttributeValue, conditionExpression string, exprAttrNames map[string]string, exprAttrValues map[string]models.AttributeValue, returnValues string) (map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        // 1. Extract Key Fields
        keyTuple, err := s.buildKeyTuple(table, key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 2. Always fetch old item for index maintenance AND conditional checks
        <span class="cov8" title="1">oldItem, err := s.getItemInternal(tr, table, keyTuple)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 3. Conditional Check
        <span class="cov8" title="1">if conditionExpression != "" </span><span class="cov8" title="1">{
                evalItem := oldItem
                if evalItem == nil </span><span class="cov0" title="0">{
                        evalItem = make(map[string]models.AttributeValue)
                }</span>
                <span class="cov8" title="1">match, err := s.evaluator.EvaluateFilter(evalItem, conditionExpression, exprAttrNames, exprAttrValues)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if !match </span><span class="cov8" title="1">{
                        return nil, models.New("ConditionalCheckFailedException", "The conditional request failed")
                }</span>
        }

        // 4. Delete
        <span class="cov8" title="1">tableDir, err := s.dir.Open(tr, []string{"tables", table.TableName}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">itemKey := tableDir.Pack(append(tuple.Tuple{"data"}, keyTuple...))
        tr.Clear(itemKey)

        // 5. Update Indexes
        if err := s.updateIndexes(tr, table, oldItem, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 6. Write to History (PITR)
        // For Delete, we record "Deleted=true" and include the OLD item for context if needed,
        // or just the keys. But `writeHistoryRecord` takes the item.
        // If we are deleting, the "Item at Time T" is "Deleted".
        // We pass the oldItem so we can recover the key.
        <span class="cov8" title="1">if err := s.writeHistoryRecord(tr, table, oldItem, true); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 7. Stream Record
        <span class="cov8" title="1">if oldItem != nil </span><span class="cov8" title="1">{ // Only stream if something was deleted
                if err := s.writeStreamRecord(tr, table, "REMOVE", oldItem, nil); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if returnValues == "ALL_OLD" </span><span class="cov8" title="1">{
                return oldItem, nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

// Helpers

func (s *FoundationDBStore) getTableInternal(rtr fdbadapter.FDBReadTransaction, tableName string) (*models.Table, error) <span class="cov8" title="1">{
        exists, err := s.dir.Exists(rtr, []string{"tables", tableName})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">tableDir, err := s.dir.Open(rtr, []string{"tables", tableName}, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">val, err := rtr.Get(tableDir.Pack(tuple.Tuple{"metadata"})).Get()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if val == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var table models.Table
        if err := json.Unmarshal(val, &amp;table); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;table, nil</span>
}

func (s *FoundationDBStore) getItemInternal(rt fdbadapter.FDBReadTransaction, table *models.Table, keyTuple []tuple.TupleElement) (map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        tableDir, err := s.dir.Open(rt, []string{"tables", table.TableName}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">itemKey := tableDir.Pack(append(tuple.Tuple{"data"}, keyTuple...))
        valBytes, err := rt.Get(itemKey.FDBKey()).Get()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(valBytes) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var item map[string]models.AttributeValue
        if err := json.Unmarshal(valBytes, &amp;item); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return item, nil</span>
}

func (s *FoundationDBStore) buildKeyTuple(table *models.Table, item map[string]models.AttributeValue) ([]tuple.TupleElement, error) <span class="cov8" title="1">{
        return s.buildKeyTupleFromSchema(table.KeySchema, item)
}</span>

func (s *FoundationDBStore) buildKeyTupleFromSchema(keySchema []models.KeySchemaElement, item map[string]models.AttributeValue) ([]tuple.TupleElement, error) <span class="cov8" title="1">{
        var pkHashName, pkRangeName string
        for _, k := range keySchema </span><span class="cov8" title="1">{
                if k.KeyType == "HASH" </span><span class="cov8" title="1">{
                        pkHashName = k.AttributeName
                }</span> else<span class="cov8" title="1"> if k.KeyType == "RANGE" </span><span class="cov8" title="1">{
                        pkRangeName = k.AttributeName
                }</span>
        }

        <span class="cov8" title="1">if pkHashName == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("schema has no HASH key")
        }</span>

        <span class="cov8" title="1">hashVal, ok := item[pkHashName]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing HASH key: %s", pkHashName)
        }</span>
        <span class="cov8" title="1">hashTupleElem, err := toTupleElement(hashVal)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">elems := []tuple.TupleElement{hashTupleElem}

        if pkRangeName != "" </span><span class="cov8" title="1">{
                rangeVal, ok := item[pkRangeName]
                if !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("missing RANGE key: %s", pkRangeName)
                }</span>
                <span class="cov8" title="1">rangeTupleElem, err := toTupleElement(rangeVal)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">elems = append(elems, rangeTupleElem)</span>
        }

        <span class="cov8" title="1">return elems, nil</span>
}

func toTupleElement(av models.AttributeValue) (tuple.TupleElement, error) <span class="cov8" title="1">{
        if av.S != nil </span><span class="cov8" title="1">{
                return *av.S, nil
        }</span>
        <span class="cov8" title="1">if av.N != nil </span><span class="cov8" title="1">{
                // Store numbers as strings/bytes or convert?
                // FDB Tuple layer supports integers and floats. DynamoDB numbers are arbitrary precision strings.
                // For MVP simplicity and sorting correctness for common numbers, maybe store as string?
                // Actually, DynamoDB strings sort differently than numbers.
                // If we store as string in tuple, "10" comes before "2". That's wrong for numbers.
                // We should try to parse as float64 or int64 if possible for ordering.
                // But for exact equality matching (Hash key), string is fine.
                // Range keys need proper ordering.
                // Let's store as string for MVP to ensure round-trip accuracy, realizing range queries might be lexicographical on the string rep.
                return *av.N, nil
        }</span>
        <span class="cov8" title="1">if av.B != nil </span><span class="cov8" title="1">{
                return []byte(*av.B), nil
        }</span>
        // ... other types ...
        // For PKs, usually only S, N, B are allowed.
        <span class="cov8" title="1">return nil, fmt.Errorf("unsupported key type or null")</span>
}

// UpdateItem updates an existing item.
func (s *FoundationDBStore) UpdateItem(ctx context.Context, tableName string, key map[string]models.AttributeValue, updateExpression string, conditionExpression string, exprAttrNames map[string]string, exprAttrValues map[string]models.AttributeValue, returnValues string) (map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        val, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                table, err := s.getTableInternal(tr, tableName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>
                <span class="cov8" title="1">return s.updateItemInternal(tr, table, key, updateExpression, conditionExpression, exprAttrNames, exprAttrValues, returnValues)</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if v, ok := val.(map[string]models.AttributeValue); ok </span><span class="cov8" title="1">{
                return v, nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func (s *FoundationDBStore) updateItemInternal(tr fdbadapter.FDBTransaction, table *models.Table, key map[string]models.AttributeValue, updateExpression string, conditionExpression string, exprAttrNames map[string]string, exprAttrValues map[string]models.AttributeValue, returnValues string) (map[string]models.AttributeValue, error) <span class="cov8" title="1">{
        // 1. Extract Key Fields
        keyTuple, err := s.buildKeyTuple(table, key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 2. Open Directory
        <span class="cov8" title="1">tableDir, err := s.dir.Open(tr, []string{"tables", table.TableName}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">itemKey := tableDir.Pack(append(tuple.Tuple{"data"}, keyTuple...))

        // 3. Read Existing Item
        existingBytes, err := tr.Get(itemKey).Get()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var item map[string]models.AttributeValue
        if existingBytes != nil </span><span class="cov8" title="1">{
                if err := json.Unmarshal(existingBytes, &amp;item); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                // Item doesn't exist. Create new one initialized with Key.
                item = make(map[string]models.AttributeValue)
                for k, v := range key </span><span class="cov8" title="1">{
                        item[k] = v
                }</span>
        }

        // Capture old item for return values, index maintenance, and conditions
        <span class="cov8" title="1">var oldItem map[string]models.AttributeValue
        if existingBytes != nil </span><span class="cov8" title="1">{
                oldItem = make(map[string]models.AttributeValue)
                for k, v := range item </span><span class="cov8" title="1">{
                        oldItem[k] = v
                }</span>
        }

        // 4. Conditional Check
        <span class="cov8" title="1">if conditionExpression != "" </span><span class="cov8" title="1">{
                evalItem := oldItem
                if evalItem == nil </span><span class="cov8" title="1">{
                        evalItem = make(map[string]models.AttributeValue)
                }</span>
                <span class="cov8" title="1">match, err := s.evaluator.EvaluateFilter(evalItem, conditionExpression, exprAttrNames, exprAttrValues)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !match </span><span class="cov0" title="0">{
                        return nil, models.New("ConditionalCheckFailedException", "The conditional request failed")
                }</span>
        }

        // 5. Apply Update Expression
        <span class="cov8" title="1">changed := make(map[string]bool)
        if updateExpression != "" </span><span class="cov8" title="1">{
                c, err := applyUpdateExpression(item, updateExpression, exprAttrNames, exprAttrValues)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">changed = c</span>
        }

        // 5a. Validate PK not changed
        <span class="cov8" title="1">for _, k := range table.KeySchema </span><span class="cov8" title="1">{
                if changed[k.AttributeName] </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("cannot update attribute %s. This is part of the key", k.AttributeName)
                }</span>
        }

        // 6. Serialize and Write
        <span class="cov8" title="1">itemBytes, err := json.Marshal(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tr.Set(itemKey, itemBytes)

        // 7. Update Indexes
        if err := s.updateIndexes(tr, table, oldItem, item); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 8. Write to History (PITR)
        <span class="cov8" title="1">if err := s.writeHistoryRecord(tr, table, item, false); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 9. Stream Record
        <span class="cov8" title="1">eventName := "MODIFY"
        if oldItem == nil </span><span class="cov8" title="1">{
                eventName = "INSERT" // It was a new item (Upsert)
        }</span>
        <span class="cov8" title="1">if err := s.writeStreamRecord(tr, table, eventName, oldItem, item); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 9. Handle ReturnValues
        <span class="cov8" title="1">if returnValues == "ALL_OLD" </span><span class="cov8" title="1">{
                return oldItem, nil
        }</span>
        <span class="cov8" title="1">if returnValues == "ALL_NEW" </span><span class="cov8" title="1">{
                return item, nil
        }</span>
        <span class="cov8" title="1">if returnValues == "UPDATED_OLD" </span><span class="cov8" title="1">{
                res := make(map[string]models.AttributeValue)
                for k := range changed </span><span class="cov8" title="1">{
                        if v, ok := oldItem[k]; ok </span><span class="cov8" title="1">{
                                res[k] = v
                        }</span>
                }
                <span class="cov8" title="1">return res, nil</span>
        }
        <span class="cov8" title="1">if returnValues == "UPDATED_NEW" </span><span class="cov8" title="1">{
                res := make(map[string]models.AttributeValue)
                for k := range changed </span><span class="cov8" title="1">{
                        if v, ok := item[k]; ok </span><span class="cov8" title="1">{
                                res[k] = v
                        }</span>
                }
                <span class="cov8" title="1">return res, nil</span>
        }
        <span class="cov8" title="1">return nil, nil</span> // NONE
}

func (s *FoundationDBStore) conditionCheckInternal(tr fdbadapter.FDBTransaction, table *models.Table, key map[string]models.AttributeValue, conditionExpression string, exprAttrNames map[string]string, exprAttrValues map[string]models.AttributeValue) error <span class="cov8" title="1">{
        keyTuple, err := s.buildKeyTuple(table, key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tableDir, err := s.dir.Open(tr, []string{"tables", table.TableName}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">itemKey := tableDir.Pack(append(tuple.Tuple{"data"}, keyTuple...))

        // Read Existing
        existingBytes, err := tr.Get(itemKey).Get()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var item map[string]models.AttributeValue
        if existingBytes != nil </span><span class="cov8" title="1">{
                if err := json.Unmarshal(existingBytes, &amp;item); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                item = make(map[string]models.AttributeValue)
        }</span>

        // Evaluate
        <span class="cov8" title="1">match, err := s.evaluator.EvaluateFilter(item, conditionExpression, exprAttrNames, exprAttrValues)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if !match </span><span class="cov8" title="1">{
                return models.New("ConditionalCheckFailedException", "The conditional request failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *FoundationDBStore) TransactGetItems(ctx context.Context, transactItems []models.TransactGetItem) ([]models.ItemResponse, error) <span class="cov8" title="1">{
        // Constraints: Max 25 items
        if len(transactItems) &gt; 25 </span><span class="cov8" title="1">{
                return nil, models.New("ValidationException", "Too many items in transaction")
        }</span>

        <span class="cov8" title="1">res, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                responses := make([]models.ItemResponse, len(transactItems))

                for i, req := range transactItems </span><span class="cov8" title="1">{
                        // 1. Get Table
                        table, err := s.getTableInternal(rtr, req.Get.TableName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                                return nil, models.New("ResourceNotFoundException", "Requested resource not found")
                        }</span>

                        // 2. Build Key
                        <span class="cov8" title="1">keyTuple, err := s.buildKeyTuple(table, req.Get.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // 3. Get Item
                        <span class="cov8" title="1">item, err := s.getItemInternal(rtr, table, keyTuple)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if req.Get.ProjectionExpression != "" </span><span class="cov8" title="1">{
                                item = s.evaluator.ProjectItem(item, req.Get.ProjectionExpression, req.Get.ExpressionAttributeNames)
                        }</span>
                        <span class="cov8" title="1">responses[i] = models.ItemResponse{Item: item}</span>
                }
                <span class="cov8" title="1">return responses, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return res.([]models.ItemResponse), nil</span>
}

func (s *FoundationDBStore) TransactWriteItems(ctx context.Context, transactItems []models.TransactWriteItem, clientRequestToken string) error <span class="cov8" title="1">{
        // Constraints
        if len(transactItems) &gt; 25 </span><span class="cov8" title="1">{
                return models.New("ValidationException", "Too many items in transaction")
        }</span>

        <span class="cov8" title="1">_, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                for _, item := range transactItems </span><span class="cov8" title="1">{
                        // Determine action
                        var tableName string
                        if item.ConditionCheck != nil </span><span class="cov8" title="1">{
                                tableName = item.ConditionCheck.TableName
                        }</span> else<span class="cov8" title="1"> if item.Put != nil </span><span class="cov8" title="1">{
                                tableName = item.Put.TableName
                        }</span> else<span class="cov8" title="1"> if item.Delete != nil </span><span class="cov8" title="1">{
                                tableName = item.Delete.TableName
                        }</span> else<span class="cov8" title="1"> if item.Update != nil </span><span class="cov8" title="1">{
                                tableName = item.Update.TableName
                        }</span> else<span class="cov8" title="1"> {
                                return nil, models.New("ValidationException", "TransactWriteItem must have one action set")
                        }</span>

                        <span class="cov8" title="1">table, err := s.getTableInternal(tr, tableName)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                                return nil, models.New("ResourceNotFoundException", "Requested resource not found: "+tableName)
                        }</span>

                        // Dispatch
                        <span class="cov8" title="1">if item.ConditionCheck != nil </span><span class="cov8" title="1">{
                                if err := s.conditionCheckInternal(tr, table, item.ConditionCheck.Key, item.ConditionCheck.ConditionExpression, item.ConditionCheck.ExpressionAttributeNames, item.ConditionCheck.ExpressionAttributeValues); err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>
                        } else<span class="cov8" title="1"> if item.Put != nil </span><span class="cov8" title="1">{
                                if _, err := s.putItemInternal(tr, table, item.Put.Item, item.Put.ConditionExpression, item.Put.ExpressionAttributeNames, item.Put.ExpressionAttributeValues, "NONE"); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov8" title="1"> if item.Delete != nil </span><span class="cov8" title="1">{
                                if _, err := s.deleteItemInternal(tr, table, item.Delete.Key, item.Delete.ConditionExpression, item.Delete.ExpressionAttributeNames, item.Delete.ExpressionAttributeValues, "NONE"); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov8" title="1"> if item.Update != nil </span><span class="cov8" title="1">{
                                if _, err := s.updateItemInternal(tr, table, item.Update.Key, item.Update.UpdateExpression, item.Update.ConditionExpression, item.Update.ExpressionAttributeNames, item.Update.ExpressionAttributeValues, "NONE"); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">return err</span>
}

// Simple expression parser for MVP supporting SET and REMOVE
func applyUpdateExpression(item map[string]models.AttributeValue, expr string, names map[string]string, values map[string]models.AttributeValue) (map[string]bool, error) <span class="cov8" title="1">{
        changed := make(map[string]bool)
        expr = strings.TrimSpace(expr)

        // Split by major sections (SET, REMOVE)
        sections := make(map[string]string)
        currentSection := ""
        var sectionWords []string

        words := strings.Fields(expr)
        for _, word := range words </span><span class="cov8" title="1">{
                upper := strings.ToUpper(word)
                if upper == "SET" || upper == "REMOVE" || upper == "ADD" || upper == "DELETE" </span><span class="cov8" title="1">{
                        if currentSection != "" </span><span class="cov8" title="1">{
                                sections[currentSection] = strings.Join(sectionWords, " ")
                        }</span>
                        <span class="cov8" title="1">currentSection = upper
                        sectionWords = nil</span>
                } else<span class="cov8" title="1"> {
                        sectionWords = append(sectionWords, word)
                }</span>
        }
        <span class="cov8" title="1">if currentSection != "" </span><span class="cov8" title="1">{
                sections[currentSection] = strings.Join(sectionWords, " ")
        }</span>

        // If no section keyword, assume SET for backward compatibility with very simple expressions
        <span class="cov8" title="1">if currentSection == "" &amp;&amp; expr != "" </span><span class="cov0" title="0">{
                sections["SET"] = expr
        }</span>

        // Helpers
        <span class="cov8" title="1">resolve := func(name string) (string, error) </span><span class="cov8" title="1">{
                if strings.HasPrefix(name, "#") </span><span class="cov8" title="1">{
                        if n, ok := names[name]; ok </span><span class="cov8" title="1">{
                                return n, nil
                        }</span>
                        <span class="cov8" title="1">return "", fmt.Errorf("missing expression attribute name: %s", name)</span>
                }
                <span class="cov8" title="1">return name, nil</span>
        }

        // Process SET
        <span class="cov8" title="1">if body, ok := sections["SET"]; ok </span><span class="cov8" title="1">{
                assignments := strings.Split(body, ",")
                for _, assignment := range assignments </span><span class="cov8" title="1">{
                        assignment = strings.TrimSpace(assignment)
                        if assignment == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">parts := strings.Split(assignment, "=")
                        if len(parts) != 2 </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("invalid assignment: %s", assignment)
                        }</span>

                        <span class="cov8" title="1">lhs := strings.TrimSpace(parts[0])
                        rhs := strings.TrimSpace(parts[1])

                        realName, err := resolve(lhs)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>

                        // Resolve RHS (Value)
                        <span class="cov8" title="1">var val models.AttributeValue
                        if strings.HasPrefix(rhs, ":") </span><span class="cov8" title="1">{
                                if v, ok := values[rhs]; ok </span><span class="cov8" title="1">{
                                        val = v
                                }</span> else<span class="cov8" title="1"> {
                                        return nil, fmt.Errorf("missing expression attribute value: %s", rhs)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                return nil, fmt.Errorf("only literal values with ':' prefix supported in MVP")
                        }</span>

                        <span class="cov8" title="1">item[realName] = val
                        changed[realName] = true</span>
                }
        }

        // Process REMOVE
        <span class="cov8" title="1">if body, ok := sections["REMOVE"]; ok </span><span class="cov8" title="1">{
                attrs := strings.Split(body, ",")
                for _, a := range attrs </span><span class="cov8" title="1">{
                        name := strings.TrimSpace(a)
                        if name == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">realName, err := resolve(name)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">delete(item, realName)
                        changed[realName] = true</span>
                }
        }

        <span class="cov8" title="1">if _, ok := sections["ADD"]; ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ADD expression not yet supported in MVP")
        }</span>
        <span class="cov8" title="1">if _, ok := sections["DELETE"]; ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DELETE expression not yet supported in MVP")
        }</span>

        <span class="cov8" title="1">return changed, nil</span>
}

// BatchGetItem retrieves multiple items from multiple tables.
func (s *FoundationDBStore) BatchGetItem(ctx context.Context, requestItems map[string]models.KeysAndAttributes) (map[string][]map[string]models.AttributeValue, map[string]models.KeysAndAttributes, error) <span class="cov8" title="1">{
        responses := make(map[string][]map[string]models.AttributeValue)
        unprocessed := make(map[string]models.KeysAndAttributes)

        // Real implementation with Futures
        res, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                type futureItem struct {
                        tableName string
                        future    fdbadapter.FDBFutureByteSlice
                }
                var futures []futureItem

                // 1. Launch reads
                for tableName, ka := range requestItems </span><span class="cov8" title="1">{
                        table, err := s.getTableInternal(rtr, tableName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                                return nil, models.New("ResourceNotFoundException", "Requested resource not found")
                        }</span>
                        <span class="cov8" title="1">tableDir, err := s.dir.Open(rtr, []string{"tables", tableName}, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">for _, key := range ka.Keys </span><span class="cov8" title="1">{
                                keyTuple, err := s.buildKeyTuple(table, key)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">itemKey := tableDir.Pack(append(tuple.Tuple{"data"}, keyTuple...))
                                futures = append(futures, futureItem{
                                        tableName: tableName,
                                        future:    rtr.Get(itemKey),
                                })</span>
                        }
                }

                // 2. Collect results
                <span class="cov8" title="1">finalResponses := make(map[string][]map[string]models.AttributeValue)
                for _, f := range futures </span><span class="cov8" title="1">{
                        valBytes, err := f.future.Get()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if len(valBytes) == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">var item map[string]models.AttributeValue
                        if err := json.Unmarshal(valBytes, &amp;item); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">finalResponses[f.tableName] = append(finalResponses[f.tableName], item)</span>
                }
                <span class="cov8" title="1">return finalResponses, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">responses = res.(map[string][]map[string]models.AttributeValue)
        return responses, unprocessed, nil</span> // UnprocessedKeys unused in happy path MVP
}

// BatchWriteItem writes or deletes multiple items.
func (s *FoundationDBStore) BatchWriteItem(ctx context.Context, requestItems map[string][]models.WriteRequest) (map[string][]models.WriteRequest, error) <span class="cov8" title="1">{
        unprocessed := make(map[string][]models.WriteRequest)

        _, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                for tableName, requests := range requestItems </span><span class="cov8" title="1">{
                        table, err := s.getTableInternal(tr, tableName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                                return nil, models.New("ResourceNotFoundException", "Requested resource not found: "+tableName)
                        }</span>

                        <span class="cov8" title="1">for _, req := range requests </span><span class="cov8" title="1">{
                                if req.PutRequest != nil </span><span class="cov8" title="1">{
                                        if _, err := s.putItemInternal(tr, table, req.PutRequest.Item, "", nil, nil, "NONE"); err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                } else<span class="cov8" title="1"> if req.DeleteRequest != nil </span><span class="cov8" title="1">{
                                        if _, err := s.deleteItemInternal(tr, table, req.DeleteRequest.Key, "", nil, nil, "NONE"); err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return unprocessed, nil</span>
}

// writeStreamRecord writes a Stream record to the FDB if streaming is enabled.
func (s *FoundationDBStore) writeStreamRecord(tr fdbadapter.FDBTransaction, table *models.Table, eventName string, oldImage, newImage map[string]models.AttributeValue) error <span class="cov8" title="1">{
        if table.StreamSpecification == nil || !table.StreamSpecification.StreamEnabled </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">viewType := table.StreamSpecification.StreamViewType

        // Create inner StreamRecord
        streamRecord := models.StreamRecord{
                ApproximateCreationDateTime: float64(time.Now().Unix()),
                Keys:                        s.extractKeys(table, oldImage, newImage),
                StreamViewType:              viewType,
                // SequenceNumber will be set by the versionstamp efficiently if we could,
                // but since it's inside the value JSON, we can't easily versionstamp it dynamically
                // without a second read. For now, we leave it empty or use a placeholder.
                // Real DynamoDB puts the sequence number here.
                // We might need to rethink this if we strictly need it in the payload.
                SequenceNumber: "PENDING",
                SizeBytes:      0,
        }

        // Filter based on ViewType
        if viewType == "NEW_IMAGE" || viewType == "NEW_AND_OLD_IMAGES" </span><span class="cov8" title="1">{
                streamRecord.NewImage = newImage
        }</span>
        <span class="cov8" title="1">if viewType == "OLD_IMAGE" || viewType == "NEW_AND_OLD_IMAGES" </span><span class="cov8" title="1">{
                streamRecord.OldImage = oldImage
        }</span>

        // Create outer Record
        <span class="cov8" title="1">record := models.Record{
                AwsRegion:    "local",
                Dynamodb:     streamRecord,
                EventID:      uuid.New().String(),
                EventName:    eventName,
                EventSource:  "aws:dynamodb",
                EventVersion: "1.1",
        }

        recordBytes, err := json.Marshal(record)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Key Structure: ["tables", tableName, "stream", "shard-0000", &lt;versionstamp&gt;]
        <span class="cov8" title="1">shardId := "shard-0000"
        streamDir, err := s.dir.CreateOrOpen(tr, []string{"tables", table.TableName, "stream", shardId}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use SetVersionstampedKey
        <span class="cov8" title="1">t := tuple.Tuple{tuple.IncompleteVersionstamp(0)}
        key, err := t.PackWithVersionstamp(streamDir.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tr.SetVersionstampedKey(fdb.Key(key), recordBytes)

        return nil</span>
}

// extractKeys extracts the primary key (PK and SK) from attributes.
func (s *FoundationDBStore) extractKeys(table *models.Table, oldItem, newItem map[string]models.AttributeValue) map[string]models.AttributeValue <span class="cov8" title="1">{
        keys := make(map[string]models.AttributeValue)
        source := newItem
        if source == nil </span><span class="cov8" title="1">{
                source = oldItem
        }</span>
        <span class="cov8" title="1">if source == nil </span><span class="cov8" title="1">{
                return keys
        }</span>

        <span class="cov8" title="1">for _, ks := range table.KeySchema </span><span class="cov8" title="1">{
                if val, ok := source[ks.AttributeName]; ok </span><span class="cov8" title="1">{
                        keys[ks.AttributeName] = val
                }</span>
        }
        <span class="cov8" title="1">return keys</span>
}

// Stream APIs

// ListStreams lists the streams.
// Note: This implementation scans tables to find active streams, which is suitable for MVP.
func (s *FoundationDBStore) ListStreams(ctx context.Context, tableName string, limit int, exclusiveStartStreamArn string) ([]models.StreamSummary, string, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>
        <span class="cov8" title="1">if limit &gt; 100 </span><span class="cov8" title="1">{
                limit = 100
        }</span>

        // Calculate start table name from ARN if provided
        <span class="cov8" title="1">var startTableName string
        if exclusiveStartStreamArn != "" </span><span class="cov8" title="1">{
                // Format: arn:aws:dynamodb:local:000000000000:table/TableName/stream/Timestamp
                parts := strings.Split(exclusiveStartStreamArn, "/")
                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                        // Find the table part. Usually it's in the part that contains ":table"
                        for i, p := range parts </span><span class="cov8" title="1">{
                                if (p == "table" || strings.Contains(p, ":table")) &amp;&amp; i+1 &lt; len(parts) </span><span class="cov8" title="1">{
                                        startTableName = parts[i+1]
                                        break</span>
                                }
                        }
                }
        }
        // If tableName filter is provided, we just check that one table.
        // But ListStreams API is usually global unless specific filtering logic?
        // DynamoDB ListStreams expects "TableName" as optional filter.
        // If TableName provided, we just return that table's stream if any.

        <span class="cov8" title="1">summaries := []models.StreamSummary{}
        var lastEvaluatedStreamArn string

        if tableName != "" </span><span class="cov8" title="1">{
                // Specific table
                table, err := s.GetTable(ctx, tableName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>
                <span class="cov8" title="1">if table != nil &amp;&amp; table.StreamSpecification != nil &amp;&amp; table.StreamSpecification.StreamEnabled </span><span class="cov8" title="1">{
                        // Only return if it matches start ARN criteria (simplified: if start ARN provided, we might skip if it's same? logic is complex, assuming simple case)
                        if exclusiveStartStreamArn != "" &amp;&amp; table.LatestStreamArn == exclusiveStartStreamArn </span>{<span class="cov8" title="1">
                                // skip
                        }</span> else<span class="cov8" title="1"> {
                                summaries = append(summaries, models.StreamSummary{
                                        StreamArn:   table.LatestStreamArn,
                                        StreamLabel: table.LatestStreamLabel,
                                        TableName:   table.TableName,
                                })
                        }</span>
                }
                <span class="cov8" title="1">return summaries, "", nil</span>
        }

        // Scan tables
        // tables, lastTable, err := s.ListTables(ctx, limit, startTableName)
        // We do manual scan to populate stream info.
        // Getting one by one is N+1 but ok for MVP.

        // Issue: We might scan 100 tables and find 0 streams. Pagination becomes hard.
        // Better approach: Scan tables until we find 'limit' streams or hit end.
        // Since we reused ListTables which relies on FDB range scan of table names, we can do manual scan here.

        // Manual Scan of Table Metadata
        <span class="cov8" title="1">chunkSize := limit
        currentStart := startTableName

        for len(summaries) &lt; limit </span><span class="cov8" title="1">{
                names, last, err := s.ListTables(ctx, chunkSize, currentStart)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, "", err
                }</span>
                <span class="cov8" title="1">if len(names) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">for _, name := range names </span><span class="cov8" title="1">{
                        // Optimization: Should use ReadTransact for batch, but GetTable is clean.
                        // Let's rely on GetTable
                        t, err := s.GetTable(ctx, name)
                        if err != nil </span><span class="cov8" title="1">{
                                // skip or error? skip
                                continue</span>
                        }
                        <span class="cov8" title="1">if t != nil &amp;&amp; t.StreamSpecification != nil &amp;&amp; t.StreamSpecification.StreamEnabled </span><span class="cov8" title="1">{
                                // Check strict ordering vs exclusiveStartStreamArn
                                if exclusiveStartStreamArn != "" &amp;&amp; t.LatestStreamArn == exclusiveStartStreamArn </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">summaries = append(summaries, models.StreamSummary{
                                        StreamArn:   t.LatestStreamArn,
                                        StreamLabel: t.LatestStreamLabel,
                                        TableName:   t.TableName,
                                })</span>
                        }
                        <span class="cov8" title="1">if len(summaries) &gt;= limit </span><span class="cov8" title="1">{
                                lastEvaluatedStreamArn = summaries[len(summaries)-1].StreamArn
                                break</span>
                        }
                }

                <span class="cov8" title="1">if last == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">currentStart = last</span>
        }

        <span class="cov8" title="1">return summaries, lastEvaluatedStreamArn, nil</span>
}

// DescribeStream returns details about a stream.
func (s *FoundationDBStore) DescribeStream(ctx context.Context, streamArn string, limit int, exclusiveStartShardId string) (*models.StreamDescription, error) <span class="cov8" title="1">{
        // Parse TableName from ARN
        parts := strings.Split(streamArn, "/")
        if len(parts) &lt; 4 </span><span class="cov8" title="1">{
                return nil, models.New("ValidationException", "Invalid Stream ARN")
        }</span>
        <span class="cov8" title="1">tableName := parts[len(parts)-3] // table/NAME/stream/LABEL -&gt; NAME at -3?
        // parts: [arn:aws:dynamodb:local:000000000000:table, TableName, stream, Label]
        // 0: prefix...table
        // 1: TableName
        // 2: stream
        // 3: Label
        // Split by "/" might not be enough if prefix has /? arn usually colons. resource part has /.
        // "arn:aws:dynamodb:local:000000000000:table/MyTable/stream/Label"
        // Split("/"):
        // 0: arn:aws:dynamodb:local:000000000000:table
        // 1: MyTable
        // 2: stream
        // 3: Label

        tableName = parts[1]

        table, err := s.GetTable(ctx, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                return nil, models.New("ResourceNotFoundException", "Table not found")
        }</span>

        <span class="cov8" title="1">if table.LatestStreamArn != streamArn </span><span class="cov8" title="1">{
                return nil, models.New("ResourceNotFoundException", "Stream not found")
        }</span>

        <span class="cov8" title="1">if table.Status != models.StatusActive </span>{<span class="cov8" title="1">
                // Streams might still exist?
        }</span>

        // Shards
        // For MVP, we have one shard: "shard-0000"
        <span class="cov8" title="1">shards := []models.Shard{}

        // Determine Sequence Numbers (approx)
        // We can't easily get strict start/end without querying.
        // We'll return open-ended shard.

        shards = append(shards, models.Shard{
                ShardId: "shard-0000",
                SequenceNumberRange: &amp;models.SequenceNumberRange{
                        StartingSequenceNumber: "00000000000000000000", // Start
                },
        })

        desc := &amp;models.StreamDescription{
                StreamArn:               streamArn,
                StreamLabel:             table.LatestStreamLabel,
                StreamStatus:            "ENABLED",
                StreamViewType:          table.StreamSpecification.StreamViewType,
                CreationRequestDateTime: float64(table.CreationDateTime.Unix()), // Approx
                TableName:               tableName,
                KeySchema:               table.KeySchema,
                Shards:                  shards,
        }

        return desc, nil</span>
}

// Iterator Structure
type ShardIteratorData struct {
        StreamArn    string
        ShardId      string
        IteratorType string
        SequenceNum  string // Hex string of 10-byte FDB versionstamp
}

// GetShardIterator returns a shard iterator.
func (s *FoundationDBStore) GetShardIterator(ctx context.Context, streamArn string, shardId string, shardIteratorType string, sequenceNumber string) (string, error) <span class="cov8" title="1">{
        data := ShardIteratorData{
                StreamArn:    streamArn,
                ShardId:      shardId,
                IteratorType: shardIteratorType,
                SequenceNum:  sequenceNumber,
        }

        js, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString(js), nil</span>
}

// GetRecords retrieves records from a shard using an iterator.
func (s *FoundationDBStore) GetRecords(ctx context.Context, shardIterator string, limit int) ([]models.Record, string, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 1000 // default
        }</span>

        // Decode
        <span class="cov8" title="1">js, err := base64.StdEncoding.DecodeString(shardIterator)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", models.New("ValidationException", "Invalid ShardIterator")
        }</span>
        <span class="cov8" title="1">var data ShardIteratorData
        if err := json.Unmarshal(js, &amp;data); err != nil </span><span class="cov8" title="1">{
                return nil, "", models.New("ValidationException", "Invalid ShardIterator JSON")
        }</span>

        // Parse TableName from ARN
        <span class="cov8" title="1">parts := strings.Split(data.StreamArn, "/")
        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return nil, "", models.New("ValidationException", "Invalid ARN in iterator")
        }</span>
        <span class="cov8" title="1">tableName := parts[1]

        records := []models.Record{}
        var nextSeqNum string

        // Read from FDB
        res, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                streamDir, err := s.dir.Open(rtr, []string{"tables", tableName, "stream", data.ShardId}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Construct Range
                <span class="cov8" title="1">var beginSel fdb.Selectable
                beginSel = fdb.FirstGreaterOrEqual(fdb.Key(streamDir.Bytes())) // Default start

                if data.IteratorType == "AFTER_SEQUENCE_NUMBER" &amp;&amp; data.SequenceNum != "" </span><span class="cov8" title="1">{
                        // Parse Hex
                        seqBytes, err := hex.DecodeString(data.SequenceNum)
                        if err == nil &amp;&amp; len(seqBytes) == 12 </span><span class="cov8" title="1">{
                                // Reconstruct versionstamp
                                var tv [10]byte
                                copy(tv[:], seqBytes[0:10])
                                uv := uint16(seqBytes[10])&lt;&lt;8 | uint16(seqBytes[11])

                                t := tuple.Tuple{tuple.Versionstamp{TransactionVersion: tv, UserVersion: uv}}
                                // Pack using standard Pack, because it is Complete
                                key := streamDir.Pack(t)
                                beginSel = fdb.FirstGreaterThan(fdb.Key(key))
                        }</span>
                }

                // Use RangeOptions
                <span class="cov8" title="1">_, end := streamDir.FDBRangeKeys()
                iter := rtr.GetRange(fdb.SelectorRange{Begin: beginSel.FDBKeySelector(), End: fdb.FirstGreaterOrEqual(end)}, fdb.RangeOptions{Limit: limit, Mode: fdb.StreamingModeWantAll})

                if data.IteratorType == "LATEST" </span><span class="cov8" title="1">{
                        // For MVP, just return empty list and next points to current end
                        lastKv, _ := rtr.GetRange(streamDir, fdb.RangeOptions{Limit: 1, Reverse: true}).GetSliceWithError()
                        if len(lastKv) &gt; 0 </span>{<span class="cov8" title="1">
                                // We'll set nextSeqNum from this in the caller or handle here
                        }</span>
                        <span class="cov8" title="1">return []models.Record{}, nil</span>
                }

                <span class="cov8" title="1">rows, err := iter.GetSliceWithError()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">records := []models.Record{}
                for _, row := range rows </span><span class="cov8" title="1">{
                        var rec models.Record
                        if err := json.Unmarshal(row.Value, &amp;rec); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Extract Versionstamp from Key to set SequenceNumber
                        <span class="cov8" title="1">t, err := streamDir.Unpack(row.Key)
                        if err == nil &amp;&amp; len(t) &gt; 0 </span><span class="cov8" title="1">{
                                if vs, ok := t[0].(tuple.Versionstamp); ok </span><span class="cov8" title="1">{
                                        uv := vs.UserVersion
                                        seqBytes := make([]byte, 12)
                                        copy(seqBytes[0:10], vs.TransactionVersion[:])
                                        seqBytes[10] = byte(uv &gt;&gt; 8)
                                        seqBytes[11] = byte(uv)
                                        rec.Dynamodb.SequenceNumber = fmt.Sprintf("%x", seqBytes)
                                        nextSeqNum = rec.Dynamodb.SequenceNumber
                                }</span>
                        }

                        <span class="cov8" title="1">records = append(records, rec)</span>
                }
                <span class="cov8" title="1">return records, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">records = res.([]models.Record)

        // Next Iterator
        // If we got records, next iterator is AFTER_SEQUENCE_NUMBER of last record.
        if len(records) &gt; 0 </span><span class="cov8" title="1">{
                nextData := ShardIteratorData{
                        StreamArn:    data.StreamArn,
                        ShardId:      data.ShardId,
                        IteratorType: "AFTER_SEQUENCE_NUMBER",
                        SequenceNum:  nextSeqNum,
                }
                jb, _ := json.Marshal(nextData)
                return records, base64.StdEncoding.EncodeToString(jb), nil
        }</span>

        // If no records, return same iterator? Or null?
        // DynamoDB returns next iterator to poll again.
        // If we are at end, we return same/updated iterator.
        <span class="cov8" title="1">return records, shardIterator, nil</span>
}

// CreateGlobalTable creates a global table.
func (s *FoundationDBStore) CreateGlobalTable(ctx context.Context, request *models.CreateGlobalTableRequest) (*models.GlobalTableDescription, error) <span class="cov8" title="1">{
        if request.GlobalTableName == "" </span><span class="cov8" title="1">{
                return nil, models.New("ValidationException", "GlobalTableName cannot be empty")
        }</span>
        <span class="cov8" title="1">desc, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // Store global table metadata in a specific directory
                globalDir, err := s.dir.CreateOrOpen(tr, []string{"global_tables", request.GlobalTableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Check if it already exists
                <span class="cov8" title="1">metaKey := globalDir.Pack(tuple.Tuple{"metadata"})
                existing, err := tr.Get(metaKey).Get()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if existing != nil </span><span class="cov8" title="1">{
                        return nil, models.New("GlobalTableAlreadyExistsException", "Global table already exists: "+request.GlobalTableName)
                }</span>

                <span class="cov8" title="1">now := float64(time.Now().Unix())
                description := models.GlobalTableDescription{
                        GlobalTableName:   request.GlobalTableName,
                        GlobalTableStatus: "CREATING",
                        CreationDateTime:  now,
                        GlobalTableArn:    fmt.Sprintf("arn:aws:dynamodb:local:000000000000:global-table/%s", request.GlobalTableName),
                        ReplicationGroup:  make([]models.ReplicaDescription, 0),
                }

                for _, r := range request.ReplicationGroup </span><span class="cov8" title="1">{
                        description.ReplicationGroup = append(description.ReplicationGroup, models.ReplicaDescription{
                                RegionName:    r.RegionName,
                                ReplicaStatus: "ACTIVE",
                        })
                }</span>

                <span class="cov8" title="1">data, err := json.Marshal(description)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">tr.Set(metaKey, data)
                return &amp;description, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return desc.(*models.GlobalTableDescription), nil</span>
}

// UpdateGlobalTable updates a global table.
func (s *FoundationDBStore) UpdateGlobalTable(ctx context.Context, request *models.UpdateGlobalTableRequest) (*models.GlobalTableDescription, error) <span class="cov8" title="1">{
        desc, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                globalDir, err := s.dir.Open(tr, []string{"global_tables", request.GlobalTableName}, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">metaKey := globalDir.Pack(tuple.Tuple{"metadata"})
                existing, err := tr.Get(metaKey).Get()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if existing == nil </span><span class="cov0" title="0">{
                        return nil, models.New("GlobalTableNotFoundException", "Global table not found: "+request.GlobalTableName)
                }</span>

                <span class="cov8" title="1">var description models.GlobalTableDescription
                if err := json.Unmarshal(existing, &amp;description); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Process updates
                <span class="cov8" title="1">for _, update := range request.ReplicaUpdates </span><span class="cov8" title="1">{
                        if update.Create != nil </span><span class="cov8" title="1">{
                                found := false
                                for _, r := range description.ReplicationGroup </span><span class="cov8" title="1">{
                                        if r.RegionName == update.Create.RegionName </span><span class="cov0" title="0">{
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                        description.ReplicationGroup = append(description.ReplicationGroup, models.ReplicaDescription{
                                                RegionName:    update.Create.RegionName,
                                                ReplicaStatus: "ACTIVE",
                                        })
                                }</span>
                        } else<span class="cov8" title="1"> if update.Delete != nil </span><span class="cov8" title="1">{
                                newGroup := make([]models.ReplicaDescription, 0)
                                for _, r := range description.ReplicationGroup </span><span class="cov8" title="1">{
                                        if r.RegionName != update.Delete.RegionName </span><span class="cov8" title="1">{
                                                newGroup = append(newGroup, r)
                                        }</span>
                                }
                                <span class="cov8" title="1">description.ReplicationGroup = newGroup</span>
                        }
                }

                <span class="cov8" title="1">data, err := json.Marshal(description)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">tr.Set(metaKey, data)
                return &amp;description, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return desc.(*models.GlobalTableDescription), nil</span>
}

// DescribeGlobalTable describes a global table.
func (s *FoundationDBStore) DescribeGlobalTable(ctx context.Context, globalTableName string) (*models.GlobalTableDescription, error) <span class="cov8" title="1">{
        desc, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                exists, err := s.dir.Exists(rtr, []string{"global_tables", globalTableName})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                        return nil, models.New("GlobalTableNotFoundException", "Global table not found: "+globalTableName)
                }</span>

                <span class="cov8" title="1">globalDir, err := s.dir.Open(rtr, []string{"global_tables", globalTableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">metaKey := globalDir.Pack(tuple.Tuple{"metadata"})
                data, err := rtr.Get(metaKey).Get()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if data == nil </span><span class="cov0" title="0">{
                        return nil, models.New("GlobalTableNotFoundException", "Global table not found: "+globalTableName)
                }</span>

                <span class="cov8" title="1">var description models.GlobalTableDescription
                if err := json.Unmarshal(data, &amp;description); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return &amp;description, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return desc.(*models.GlobalTableDescription), nil</span>
}

// ListGlobalTables lists global tables.
func (s *FoundationDBStore) ListGlobalTables(ctx context.Context, limit int, exclusiveStartGlobalTableName string) ([]models.GlobalTable, string, error) <span class="cov8" title="1">{
        res, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // We can use s.dir.List if it was available, but we need to list subdirectories of "global_tables".
                // For now, let's assume we can list them.
                tableNames, err := s.dir.List(rtr, []string{"global_tables"}, directory.ListOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">globalTables := make([]models.GlobalTable, 0)
                for _, name := range tableNames </span><span class="cov8" title="1">{
                        if exclusiveStartGlobalTableName != "" &amp;&amp; name &lt;= exclusiveStartGlobalTableName </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if limit &gt; 0 &amp;&amp; len(globalTables) &gt;= limit </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // For each table, we might need a shallow description.
                        // DynamoDB ListGlobalTables returns GlobalTableName and ReplicationGroup.
                        // We'll fetch the full metadata to get the group, though this is less efficient.
                        <span class="cov8" title="1">globalDir, err := s.dir.Open(rtr, []string{"global_tables", name}, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">metaKey := globalDir.Pack(tuple.Tuple{"metadata"})
                        data, err := rtr.Get(metaKey).Get()
                        if err != nil || data == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">var desc models.GlobalTableDescription
                        if err := json.Unmarshal(data, &amp;desc); err == nil </span><span class="cov8" title="1">{
                                replicas := make([]models.Replica, 0)
                                for _, r := range desc.ReplicationGroup </span><span class="cov8" title="1">{
                                        replicas = append(replicas, models.Replica{RegionName: r.RegionName})
                                }</span>
                                <span class="cov8" title="1">globalTables = append(globalTables, models.GlobalTable{
                                        GlobalTableName:  name,
                                        ReplicationGroup: replicas,
                                })</span>
                        }
                }

                <span class="cov8" title="1">return globalTables, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">return res.([]models.GlobalTable), "", nil</span>
}

// cloneItem creates a deep copy of an item map.
func cloneItem(item map[string]models.AttributeValue) map[string]models.AttributeValue <span class="cov8" title="1">{
        if item == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">clone := make(map[string]models.AttributeValue, len(item))
        for k, v := range item </span><span class="cov8" title="1">{
                clone[k] = cloneAttributeValue(v)
        }</span>
        <span class="cov8" title="1">return clone</span>
}

func cloneAttributeValue(v models.AttributeValue) models.AttributeValue <span class="cov8" title="1">{
        clone := models.AttributeValue{}
        if v.S != nil </span><span class="cov8" title="1">{
                s := *v.S
                clone.S = &amp;s
        }</span>
        <span class="cov8" title="1">if v.N != nil </span><span class="cov8" title="1">{
                n := *v.N
                clone.N = &amp;n
        }</span>
        <span class="cov8" title="1">if v.B != nil </span><span class="cov8" title="1">{
                b := *v.B
                clone.B = &amp;b
        }</span>
        <span class="cov8" title="1">if v.BOOL != nil </span><span class="cov8" title="1">{
                b := *v.BOOL
                clone.BOOL = &amp;b
        }</span>
        <span class="cov8" title="1">if v.NULL != nil </span><span class="cov8" title="1">{
                n := *v.NULL
                clone.NULL = &amp;n
        }</span>
        <span class="cov8" title="1">if v.SS != nil </span><span class="cov8" title="1">{
                clone.SS = make([]string, len(v.SS))
                copy(clone.SS, v.SS)
        }</span>
        <span class="cov8" title="1">if v.NS != nil </span><span class="cov8" title="1">{
                clone.NS = make([]string, len(v.NS))
                copy(clone.NS, v.NS)
        }</span>
        <span class="cov8" title="1">if v.BS != nil </span><span class="cov8" title="1">{
                clone.BS = make([]string, len(v.BS))
                copy(clone.BS, v.BS)
        }</span>
        <span class="cov8" title="1">if v.L != nil </span><span class="cov8" title="1">{
                clone.L = make([]models.AttributeValue, len(v.L))
                for i, lv := range v.L </span><span class="cov8" title="1">{
                        clone.L[i] = cloneAttributeValue(lv)
                }</span>
        }
        <span class="cov8" title="1">if v.M != nil </span><span class="cov8" title="1">{
                clone.M = make(map[string]models.AttributeValue, len(v.M))
                for mk, mv := range v.M </span><span class="cov8" title="1">{
                        clone.M[mk] = cloneAttributeValue(mv)
                }</span>
        }
        <span class="cov8" title="1">return clone</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package store

import (
        "encoding/json"
        "fmt"

        "github.com/apple/foundationdb/bindings/go/src/fdb/tuple"
        "github.com/tabeth/concretedb/models"
        "github.com/tabeth/concretedb/store/internal/fdbadapter"
)

// updateIndexes maintains GSI and LSI entries when an item is created, updated, or deleted.
func (s *FoundationDBStore) updateIndexes(tr fdbadapter.FDBTransaction, table *models.Table, oldItem map[string]models.AttributeValue, newItem map[string]models.AttributeValue) error <span class="cov8" title="1">{
        // 1. Delete old index entries
        if len(oldItem) &gt; 0 </span><span class="cov8" title="1">{
                if err := s.deleteIndexEntries(tr, table, oldItem); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 2. Put new index entries
        <span class="cov8" title="1">if len(newItem) &gt; 0 </span><span class="cov8" title="1">{
                if err := s.putIndexEntries(tr, table, newItem); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *FoundationDBStore) deleteIndexEntries(tr fdbadapter.FDBTransaction, table *models.Table, item map[string]models.AttributeValue) error <span class="cov8" title="1">{
        // GSI
        for _, gsi := range table.GlobalSecondaryIndexes </span><span class="cov8" title="1">{
                if err := s.deleteIndexEntry(tr, table, gsi.IndexName, gsi.KeySchema, item); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // LSI
        <span class="cov8" title="1">for _, lsi := range table.LocalSecondaryIndexes </span><span class="cov8" title="1">{
                if err := s.deleteIndexEntry(tr, table, lsi.IndexName, lsi.KeySchema, item); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *FoundationDBStore) putIndexEntries(tr fdbadapter.FDBTransaction, table *models.Table, item map[string]models.AttributeValue) error <span class="cov8" title="1">{
        // GSI
        for _, gsi := range table.GlobalSecondaryIndexes </span><span class="cov8" title="1">{
                if err := s.putIndexEntry(tr, table, gsi.IndexName, gsi.KeySchema, gsi.Projection, item); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        // LSI
        <span class="cov8" title="1">for _, lsi := range table.LocalSecondaryIndexes </span><span class="cov8" title="1">{
                if err := s.putIndexEntry(tr, table, lsi.IndexName, lsi.KeySchema, lsi.Projection, item); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *FoundationDBStore) deleteIndexEntry(tr fdbadapter.FDBTransaction, table *models.Table, indexName string, keySchema []models.KeySchemaElement, item map[string]models.AttributeValue) error <span class="cov8" title="1">{
        indexKey, err := s.buildIndexKeyTuple(table, keySchema, item)
        if err != nil </span><span class="cov8" title="1">{
                if err == ErrSkipIndex </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">indexDir, err := s.dir.Open(tr, []string{"tables", table.TableName, "index", indexName}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tr.Clear(indexDir.Pack(indexKey))
        return nil</span>
}

func (s *FoundationDBStore) putIndexEntry(tr fdbadapter.FDBTransaction, table *models.Table, indexName string, keySchema []models.KeySchemaElement, projection models.Projection, item map[string]models.AttributeValue) error <span class="cov8" title="1">{
        indexKey, err := s.buildIndexKeyTuple(table, keySchema, item)
        if err != nil </span><span class="cov8" title="1">{
                if err == ErrSkipIndex </span><span class="cov8" title="1">{
                        return nil // Skip indexing if attributes missing
                }</span>
                // Propagate other errors (e.g. invalid type)
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">indexDir, err := s.dir.Open(tr, []string{"tables", table.TableName, "index", indexName}, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Project attributes
        <span class="cov8" title="1">var val []byte
        if projection.ProjectionType == "KEYS_ONLY" </span><span class="cov8" title="1">{
                val = []byte("{}")
        }</span> else<span class="cov8" title="1"> {
                // Project attributes
                projected := make(map[string]models.AttributeValue)

                if projection.ProjectionType == "ALL" </span><span class="cov8" title="1">{
                        projected = item
                }</span> else<span class="cov8" title="1"> if projection.ProjectionType == "INCLUDE" </span><span class="cov8" title="1">{
                        // Copy keys + included
                        for _, ks := range table.KeySchema </span><span class="cov8" title="1">{
                                if v, ok := item[ks.AttributeName]; ok </span><span class="cov8" title="1">{
                                        projected[ks.AttributeName] = v
                                }</span>
                        }
                        <span class="cov8" title="1">for _, n := range projection.NonKeyAttributes </span><span class="cov8" title="1">{
                                if v, ok := item[n]; ok </span><span class="cov8" title="1">{
                                        projected[n] = v
                                }</span>
                        }
                }

                <span class="cov8" title="1">if len(projected) &gt; 0 </span><span class="cov8" title="1">{
                        b, err := json.Marshal(projected)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">val = b</span>
                }
        }

        <span class="cov8" title="1">tr.Set(indexDir.Pack(indexKey), val)
        return nil</span>
}

var ErrSkipIndex = fmt.Errorf("skip index")

// buildIndexKeyTuple constructs the tuple key for an index entry.
func (s *FoundationDBStore) buildIndexKeyTuple(table *models.Table, indexKeySchema []models.KeySchemaElement, item map[string]models.AttributeValue) (tuple.Tuple, error) <span class="cov8" title="1">{
        // Tuple: (IndexPK, [IndexSK], TablePK, [TableSK])
        var parts tuple.Tuple

        // 1. Index Keys
        for _, ke := range indexKeySchema </span><span class="cov8" title="1">{
                val, ok := item[ke.AttributeName]
                if !ok </span><span class="cov8" title="1">{
                        return nil, ErrSkipIndex
                }</span>
                // Convert val to comparable
                <span class="cov8" title="1">v, err := toFDBElement(val)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">parts = append(parts, v)</span>
        }

        // 2. Table Keys (to ensure uniqueness)
        // We append TablePK (and TableSK if exists) to the tuple.
        // BUT, if the Index Key ALREADY includes Table Key (e.g. LSI shares PK), we shouldn't duplicate it?
        // FDB logic: The tuple forms the key.
        // GSI: (GSI_PK, GSI_SK, TablePK, TableSK).
        // LSI: (TablePK, LSI_SK, TableSK). (TablePK is already in indexKeySchema[0]).

        // Optimization: Append Table Keys ONLY if they are not already in Index Keys?
        // Or just blindly append them? strict deduplication?
        // DynamoDB GSI keys are (Partition Key, Sort Key, Table Partition Key, Table Sort Key).
        // If any overlap, they are merged? No, generally they are distinct unless same name.

        <span class="cov8" title="1">for _, ke := range table.KeySchema </span><span class="cov8" title="1">{
                // Check if already in parts?
                // Simple approach: Always append table keys.
                // For LSI: indexKeySchema[0] IS TablePK. So we duplicate it?
                // (TablePK, LSI_SK, TablePK, TableSK). This is redundant but works for uniqueness.
                // Better: Check if attribute name is already in indexKeySchema.

                isInData := false
                for _, ike := range indexKeySchema </span><span class="cov8" title="1">{
                        if ike.AttributeName == ke.AttributeName </span><span class="cov8" title="1">{
                                isInData = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !isInData </span><span class="cov8" title="1">{
                        val, ok := item[ke.AttributeName]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("missing table key attribute")
                        }</span>
                        <span class="cov8" title="1">v, err := toFDBElement(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">parts = append(parts, v)</span>
                }
        }

        <span class="cov8" title="1">return parts, nil</span>
}

// toFDBElement converts AttributeValue to tuple element
func toFDBElement(v models.AttributeValue) (tuple.TupleElement, error) <span class="cov8" title="1">{
        if v.S != nil </span><span class="cov8" title="1">{
                return *v.S, nil
        }</span>
        <span class="cov8" title="1">if v.N != nil </span><span class="cov8" title="1">{
                return *v.N, nil
        }</span>
        <span class="cov8" title="1">if v.B != nil </span><span class="cov8" title="1">{
                return []byte(*v.B), nil
        }</span>
        <span class="cov8" title="1">return nil, fmt.Errorf("unsupported index key type")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package store

import (
        "context"
        "encoding/json"

        "github.com/apple/foundationdb/bindings/go/src/fdb/tuple"
        "github.com/tabeth/concretedb/models"
        "github.com/tabeth/concretedb/store/internal/fdbadapter"
)

// UpdateTimeToLive updates the TTL configuration for a table.
func (s *FoundationDBStore) UpdateTimeToLive(ctx context.Context, request *models.UpdateTimeToLiveRequest) (*models.TimeToLiveSpecification, error) <span class="cov8" title="1">{
        val, err := s.db.Transact(func(tr fdbadapter.FDBTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                // 1. Get Table Metadata
                table, err := s.getTableInternal(tr, request.TableName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>

                // 2. Update TTL Description
                <span class="cov8" title="1">if table.TimeToLiveDescription == nil </span><span class="cov8" title="1">{
                        table.TimeToLiveDescription = &amp;models.TimeToLiveDescription{
                                TimeToLiveStatus: "DISABLED",
                        }
                }</span>

                // Simplified state transition logic for now
                <span class="cov8" title="1">if request.TimeToLiveSpecification.Enabled </span><span class="cov8" title="1">{
                        table.TimeToLiveDescription.TimeToLiveStatus = "ENABLED"
                        table.TimeToLiveDescription.AttributeName = request.TimeToLiveSpecification.AttributeName
                }</span> else<span class="cov8" title="1"> {
                        table.TimeToLiveDescription.TimeToLiveStatus = "DISABLED"
                        // Keep the attribute name even if disabled, similar to DynamoDB behavior often retaining context
                }</span>

                // 3. Save updated metadata
                <span class="cov8" title="1">tableBytes, err := json.Marshal(table)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">tableDir, err := s.dir.Open(tr, []string{"tables", table.TableName}, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tr.Set(tableDir.Pack(tuple.Tuple{"metadata"}), tableBytes)

                return &amp;request.TimeToLiveSpecification, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return val.(*models.TimeToLiveSpecification), nil</span>
}

// DescribeTimeToLive retrieves the TTL configuration for a table.
func (s *FoundationDBStore) DescribeTimeToLive(ctx context.Context, tableName string) (*models.TimeToLiveDescription, error) <span class="cov8" title="1">{
        val, err := s.db.ReadTransact(func(rtr fdbadapter.FDBReadTransaction) (interface{}, error) </span><span class="cov8" title="1">{
                table, err := s.getTableInternal(rtr, tableName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if table == nil </span><span class="cov8" title="1">{
                        return nil, ErrTableNotFound
                }</span>

                <span class="cov8" title="1">if table.TimeToLiveDescription == nil </span><span class="cov8" title="1">{
                        // Default if not set
                        return &amp;models.TimeToLiveDescription{
                                TimeToLiveStatus: "DISABLED",
                        }, nil
                }</span>

                <span class="cov8" title="1">return table.TimeToLiveDescription, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return val.(*models.TimeToLiveDescription), nil</span>
}

// Helper to get table internal (reused from foundationdb_store.go but since this is a new file we can't access private methods if they are in another file in the same package?
// No, Go allows access to private methods in the same package.
// However, I need to make sure getTableInternal is available or duplicate it.
// Checking foundationdb_store.go again... getTableInternal IS NOT exported, so I can use it if I put this code in a file in the same package.)
</pre>
		
		<pre class="file" id="file5" style="display: none">package store

// stringPtr returns a pointer to the string s.
// It is a helper for creating AttributeValues.
func stringPtr(s string) *string <span class="cov8" title="1">{
        return &amp;s
}</span>

// boolPtr returns a pointer to the bool b.
func boolPtr(b bool) *bool <span class="cov8" title="1">{
        return &amp;b
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
